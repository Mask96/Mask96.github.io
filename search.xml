<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dump-SQL中复制表结构或数据</title>
    <url>/2021/10/18/dump-SQL%E4%B8%AD%E5%A4%8D%E5%88%B6%E8%A1%A8%E7%BB%93%E6%9E%84%E6%88%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="dump命令复制数据库"><a href="#dump命令复制数据库" class="headerlink" title="dump命令复制数据库"></a>dump命令复制数据库</h1><p>mysqldump客户端可用来转储数据库或搜集数据库进行备份或将数据转移到另一个sql服务器(不一定是一个mysql服务器)。转储包含创建表和/或装载表的sql语句。</p>
<span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">导出结构：</span><br><span class="line">     mysqldump <span class="operator">-</span>hlocalhost <span class="operator">-</span>uroot <span class="operator">-</span>P3306 <span class="operator">-</span>proot <span class="operator">-</span>d database table1 table2 <span class="operator">&gt;</span>.<span class="operator">/</span>event.sql</span><br><span class="line">导出结构和数据:</span><br><span class="line">     mysqldump <span class="operator">-</span>hlocalhost <span class="operator">-</span>uroot <span class="operator">-</span>P3306 <span class="operator">-</span>proot database <span class="keyword">table</span> <span class="operator">&gt;</span> .<span class="operator">/</span>event.sql</span><br></pre></td></tr></table></figure>
<ol>
<li>加-d可以只导出结构，不导出数据</li>
<li>导出多个表可以用空格分开</li>
</ol>
<h1 id="执行生成的SQL文件"><a href="#执行生成的SQL文件" class="headerlink" title="执行生成的SQL文件"></a>执行生成的SQL文件</h1><p>在导入大的sql文件时，使用可视化工具导入往往效率极低，此时，我们常常使用在cmd中执行source命令的方式</p>
<ol>
<li>进入数据库</li>
<li>导入sql文件<code>mysql&gt; source /home/work/event.sql</code></li>
</ol>
<h1 id="dump命令参数"><a href="#dump命令参数" class="headerlink" title="dump命令参数"></a>dump命令参数</h1><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>mysqldump [选项] 数据库名 [表名] &gt; 脚本名</code><br>或<br><code>mysqldump [选项] --数据库名 [选项 表名] &gt; 脚本名</code><br>或<br><code>mysqldump [选项] --all-databases [选项]  &gt; 脚本名</code></p>
<h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数名	 缩写	含义</span><br><span class="line">--host	-h	服务器IP地址</span><br><span class="line">--port	-P	服务器端口号</span><br><span class="line">--user	-u	MySQL 用户名</span><br><span class="line">--pasword	-p	MySQL 密码</span><br><span class="line">--databases		指定要备份的数据库</span><br><span class="line">--all-databases		备份mysql服务器上的所有数据库</span><br><span class="line">--compact		压缩模式，产生更少的输出</span><br><span class="line">--comments		添加注释信息</span><br><span class="line">--complete-insert		输出完成的插入语句</span><br><span class="line">--lock-tables		备份前，锁定所有数据库表</span><br><span class="line">--no-create-db/--no-create-info		禁止生成创建数据库语句</span><br><span class="line">--force		当出现错误时仍然继续备份操作</span><br><span class="line">--default-character-set		指定默认字符集</span><br><span class="line">--add-locks		备份数据库表时锁定数据库表</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>备份所有数据库：<br><code>mysqldump -uroot -p --all-databases &gt; /backup/mysqldump/all.db</code><br>备份指定数据库：<br><code>mysqldump -uroot -p test &gt; /backup/mysqldump/test.db</code><br>备份指定数据库指定表(多个表以空格间隔)<br><code>mysqldump -uroot -p  mysql db event &gt; /backup/mysqldump/2table.db</code><br>备份指定数据库排除某些表<br><code>mysqldump -uroot -p test --ignore-table=test.t1 --ignore-table=test.t2 &gt; /backup/mysqldump/test2.db</code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA面试基础</title>
    <url>/2019/11/29/JAVA%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>本文摘自gitchat。</p>
</blockquote>
<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a>1. JDK 和 JRE 有什么区别？</h2><ul>
<li>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。<span id="more"></span></li>
</ul>
<h2 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a>2. == 和 equals 的区别是什么？</h2><p>== 解读</p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；<br>代码示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String x = &quot;string&quot;;</span><br><span class="line">String y = &quot;string&quot;;</span><br><span class="line">String z = new String(&quot;string&quot;);</span><br><span class="line">System.out.println(x==y); // true</span><br><span class="line">System.out.println(x==z); // false</span><br><span class="line">System.out.println(x.equals(y)); // true</span><br><span class="line">System.out.println(x.equals(z)); // true</span><br></pre></td></tr></table></figure>
<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>equals 解读</strong></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">    public Cat(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat c1 = new Cat(&quot;王磊&quot;);</span><br><span class="line">Cat c2 = new Cat(&quot;王磊&quot;);</span><br><span class="line">System.out.println(c1.equals(c2)); // false</span><br></pre></td></tr></table></figure>
<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = new String(&quot;老王&quot;);</span><br><span class="line">String s2 = new String(&quot;老王&quot;);</span><br><span class="line">System.out.println(s1.equals(s2)); // true</span><br></pre></td></tr></table></figure>
<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h2 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h2><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = &quot;通话&quot;;</span><br><span class="line">String str2 = &quot;重地&quot;;</span><br><span class="line">System. out. println(String. format(&quot;str1：%d | str2：%d&quot;,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure>
<p>执行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str1：1179395 | str2：1179395</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h2 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4. final 在 Java 中有什么作用？"></a>4. final 在 Java 中有什么作用？</h2><p>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h2 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. Java 中的 Math. round(-1. 5) 等于多少？"></a>5. Java 中的 Math. round(-1. 5) 等于多少？</h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h2 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a>6. String 属于基础的数据类型吗？</h2><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h2 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7. Java 中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h2 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=”i”与 String str=new String(“i”)一样吗？"></a>8. String str=”i”与 String str=new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure>

<h2 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a>10. String 类的常用方法都有那些？</h2><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class Cat &#123;</span><br><span class="line">    public static void sayHi() &#123;</span><br><span class="line">        System. out. println(&quot;hi~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h2><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h2 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a>13. 抽象类能使用 final 修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，编辑器也会提示错误信息。</p>
<h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h2><ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<h2 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15. Java 中 IO 流分为几种？"></a>15. Java 中 IO 流分为几种？</h2><ul>
<li><p>按功能来分：输入流（input）、输出流（output）。</p>
</li>
<li><p>按类型来分：字节流和字符流。</p>
</li>
<li><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
</li>
</ul>
<h2 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a>16. BIO、NIO、AIO 有什么区别？</h2><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h2 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17. Files的常用方法都有哪些？"></a>17. Files的常用方法都有哪些？</h2><ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18. Java 容器都有哪些？"></a>18. Java 容器都有哪些？</h2><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>Collection</p>
<p>-List</p>
<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
<li>Stack</li>
</ul>
<p>-Set</p>
<ul>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
<p>Map</p>
<p>-HashMap</p>
<ul>
<li>LinkedHashMap</li>
</ul>
<p>-TreeMap<br>-ConcurrentHashMap<br>-Hashtable</p>
<h2 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a>19. Collection 和 Collections 有什么区别？</h2><p>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p>
<h2 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20. List、Set、Map 之间的区别是什么？"></a>20. List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p>三者之间的区别，如下表：<br><img src="/image/java-1.jpg" alt="java-1"></p>
<h2 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a>21. HashMap 和 Hashtable 有什么区别？</h2><ul>
<li>存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</li>
<li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
</ul>
<h2 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a>22. 如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h2 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a>23. 说一下 HashMap 的实现原理？</h2><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h2 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a>24. 说一下 HashSet 的实现原理？</h2><ul>
<li>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</li>
</ul>
<h2 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a>25. ArrayList 和 LinkedList 的区别是什么？</h2><ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li>
</ul>
<h2 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a>26. 如何实现数组和 List 之间的转换？</h2><ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// list to array</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list. add(&quot;王磊&quot;);</span><br><span class="line">list. add(&quot;的博客&quot;);</span><br><span class="line">list. toArray();</span><br><span class="line">// array to list</span><br><span class="line">String[] array = new String[]&#123;&quot;王磊&quot;,&quot;的博客&quot;&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>

<h2 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27. ArrayList 和 Vector 的区别是什么？"></a>27. ArrayList 和 Vector 的区别是什么？</h2><ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<h2 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28. Array 和 ArrayList 有何区别？"></a>28. Array 和 ArrayList 有何区别？</h2><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<h2 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll()和 remove()有什么区别？"></a>29. 在 Queue 中 poll()和 remove()有什么区别？</h2><ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。<br>代码示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(&quot;string&quot;); // add</span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure>

<h2 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a>30. 哪些集合类是线程安全的？</h2><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h2 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a>31. 迭代器 Iterator 是什么？</h2><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h2 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a>32. Iterator 怎么使用？有什么特点？</h2><p>Iterator 使用代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line">while(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h2 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a>33. Iterator 和 ListIterator 有什么区别？</h2><ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h2 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34. 怎么确保一个集合不能被修改？"></a>34. 怎么确保一个集合不能被修改？</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. add(&quot;x&quot;);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(&quot;y&quot;); // 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35. 并行和并发有什么区别？"></a>35. 并行和并发有什么区别？</h2><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>如下图：<br><img src="/image/java-2-1.jpg" alt="java-2"></p>
<p>并发 = 两个队列和一台咖啡机。<br>并行 = 两个队列和两台咖啡机。</p>
<h2 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36. 线程和进程的区别？"></a>36. 线程和进程的区别？</h2><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<h2 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37. 守护线程是什么？"></a>37. 守护线程是什么？</h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h2 id="38-创建线程有哪几种方式？"><a href="#38-创建线程有哪几种方式？" class="headerlink" title="38. 创建线程有哪几种方式？"></a>38. 创建线程有哪几种方式？</h2><p>创建线程有三种方式：</p>
<ul>
<li>继承 Thread 重写 run 方法；</li>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口。</li>
</ul>
<h2 id="39-说一下-runnable-和-callable-有什么区别？"><a href="#39-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="39. 说一下 runnable 和 callable 有什么区别？"></a>39. 说一下 runnable 和 callable 有什么区别？</h2><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>
<h2 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40. 线程有哪些状态？"></a>40. 线程有哪些状态？</h2><p>线程的状态：</p>
<ul>
<li>NEW 尚未启动</li>
<li>RUNNABLE 正在执行中</li>
<li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li>
<li>WAITING 永久等待状态</li>
<li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li>
<li>TERMINATED 执行完成</li>
</ul>
<h2 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41. sleep() 和 wait() 有什么区别？"></a>41. sleep() 和 wait() 有什么区别？</h2><ul>
<li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li>
<li>释放锁：sleep() 不释放锁；wait() 释放锁。</li>
<li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</li>
</ul>
<h2 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42. notify() 和 notifyAll() 有什么区别？"></a>42. notify() 和 notifyAll() 有什么区别？</h2><p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>
<h2 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="43. 线程的 run() 和 start() 有什么区别？"></a>43. 线程的 run() 和 start() 有什么区别？</h2><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<h2 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="44. 创建线程池有哪几种方式？"></a>44. 创建线程池有哪几种方式？</h2><p>线程池创建有七种方式，最核心的是最后一种：</p>
<ul>
<li><p>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</p>
</li>
<li><p>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</p>
</li>
<li><p>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</p>
</li>
<li><p>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</p>
</li>
<li><p>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</p>
</li>
<li><p>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</p>
</li>
<li><p>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</p>
</li>
</ul>
<h2 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="45. 线程池都有哪些状态？"></a>45. 线程池都有哪些状态？</h2><ul>
<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li>
<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>
</ul>
<h2 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46. 线程池中 submit() 和 execute() 方法有什么区别？"></a>46. 线程池中 submit() 和 execute() 方法有什么区别？</h2><ul>
<li>execute()：只能执行 Runnable 类型的任务。</li>
<li>submit()：可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</li>
</ul>
<h2 id="47-在-Java-程序中怎么保证多线程的运行安全？"><a href="#47-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47. 在 Java 程序中怎么保证多线程的运行安全？"></a>47. 在 Java 程序中怎么保证多线程的运行安全？</h2><ul>
<li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li>
<li>方法二：使用自动锁 synchronized。</li>
<li>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System. out. println(&quot;获得锁&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // TODO: handle exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System. out. println(&quot;释放锁&quot;);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="48-多线程中-synchronized-锁升级的原理是什么？"><a href="#48-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="48. 多线程中 synchronized 锁升级的原理是什么？"></a>48. 多线程中 synchronized 锁升级的原理是什么？</h2><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h2 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49. 什么是死锁？"></a>49. 什么是死锁？</h2><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h2 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50. 怎么防止死锁？"></a>50. 怎么防止死锁？</h2><ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>
<li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li>
<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>尽量减少同步的代码块。</li>
</ul>
<h2 id="51-ThreadLocal-是什么？有哪些使用场景？"><a href="#51-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="51. ThreadLocal 是什么？有哪些使用场景？"></a>51. ThreadLocal 是什么？有哪些使用场景？</h2><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<h2 id="52-说一下-synchronized-底层实现原理？"><a href="#52-说一下-synchronized-底层实现原理？" class="headerlink" title="52. 说一下 synchronized 底层实现原理？"></a>52. 说一下 synchronized 底层实现原理？</h2><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<h2 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="53. synchronized 和 volatile 的区别是什么？"></a>53. synchronized 和 volatile 的区别是什么？</h2><ul>
<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
</ul>
<h2 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="54. synchronized 和 Lock 有什么区别？"></a>54. synchronized 和 Lock 有什么区别？</h2><ul>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
<h2 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="55. synchronized 和 ReentrantLock 区别是什么？"></a>55. synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li>
</ul>
<h2 id="56-说一下-atomic-的原理？"><a href="#56-说一下-atomic-的原理？" class="headerlink" title="56. 说一下 atomic 的原理？"></a>56. 说一下 atomic 的原理？</h2><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57. 什么是反射？"></a>57. 什么是反射？</h2><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<h2 id="58-什么是-Java-序列化？什么情况下需要序列化？"><a href="#58-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="58. 什么是 Java 序列化？什么情况下需要序列化？"></a>58. 什么是 Java 序列化？什么情况下需要序列化？</h2><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p>
<p>以下情况需要使用 Java 序列化：</p>
<ul>
<li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
<li>想用套接字在网络上传送对象的时候；</li>
<li>想通过RMI（远程方法调用）传输对象的时候。</li>
</ul>
<h2 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59. 动态代理是什么？有哪些应用？"></a>59. 动态代理是什么？有哪些应用？</h2><p>动态代理是运行时动态生成代理类。</p>
<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>
<h2 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60. 怎么实现动态代理？"></a>60. 怎么实现动态代理？</h2><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>
<h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><h2 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="61. 为什么要使用克隆？"></a>61. 为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>
<h2 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62. 如何实现对象克隆？"></a>62. 如何实现对象克隆？</h2><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p>
<h2 id="63-深拷贝和浅拷贝区别是什么？"><a href="#63-深拷贝和浅拷贝区别是什么？" class="headerlink" title="63. 深拷贝和浅拷贝区别是什么？"></a>63. 深拷贝和浅拷贝区别是什么？</h2><ul>
<li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li>
<li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li>
</ul>
<h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="64-JSP-和-servlet-有什么区别？"><a href="#64-JSP-和-servlet-有什么区别？" class="headerlink" title="64. JSP 和 servlet 有什么区别？"></a>64. JSP 和 servlet 有什么区别？</h2><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p>
<h2 id="65-JSP-有哪些内置对象？作用分别是什么？"><a href="#65-JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="65. JSP 有哪些内置对象？作用分别是什么？"></a>65. JSP 有哪些内置对象？作用分别是什么？</h2><p>JSP 有 9 大内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web 应用的配置对象；</li>
<li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h2 id="66-说一下-JSP-的-4-种作用域？"><a href="#66-说一下-JSP-的-4-种作用域？" class="headerlink" title="66. 说一下 JSP 的 4 种作用域？"></a>66. 说一下 JSP 的 4 种作用域？</h2><ul>
<li>page：代表与一个页面相关的对象和属性。</li>
<li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li>
<li>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h2 id="67-session-和-cookie-有什么区别？"><a href="#67-session-和-cookie-有什么区别？" class="headerlink" title="67. session 和 cookie 有什么区别？"></a>67. session 和 cookie 有什么区别？</h2><ul>
<li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li>
<li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li>
<li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li>
<li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li>
</ul>
<h2 id="68-说一下-session-的工作原理？"><a href="#68-说一下-session-的工作原理？" class="headerlink" title="68. 说一下 session 的工作原理？"></a>68. 说一下 session 的工作原理？</h2><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>
<h2 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="69. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>
<h2 id="70-spring-mvc-和-struts-的区别是什么？"><a href="#70-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="70. spring mvc 和 struts 的区别是什么？"></a>70. spring mvc 和 struts 的区别是什么？</h2><ul>
<li>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</li>
<li>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</li>
<li>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</li>
<li>对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</li>
</ul>
<h2 id="71-如何避免-SQL-注入？"><a href="#71-如何避免-SQL-注入？" class="headerlink" title="71. 如何避免 SQL 注入？"></a>71. 如何避免 SQL 注入？</h2><p>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。</p>
<h2 id="72-什么是-XSS-攻击，如何避免？"><a href="#72-什么是-XSS-攻击，如何避免？" class="headerlink" title="72. 什么是 XSS 攻击，如何避免？"></a>72. 什么是 XSS 攻击，如何避免？</h2><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p>
<p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p>
<h2 id="73-什么是-CSRF-攻击，如何避免？"><a href="#73-什么是-CSRF-攻击，如何避免？" class="headerlink" title="73. 什么是 CSRF 攻击，如何避免？"></a>73. 什么是 CSRF 攻击，如何避免？</h2><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p>
<p>防御手段：</p>
<ul>
<li>验证请求来源地址；</li>
<li>关键操作添加验证码；</li>
<li>在请求地址添加 token 并验证。</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="74-throw-和-throws-的区别？"><a href="#74-throw-和-throws-的区别？" class="headerlink" title="74. throw 和 throws 的区别？"></a>74. throw 和 throws 的区别？</h2><ul>
<li>throw：是真实抛出一个异常。</li>
<li>throws：是声明可能会抛出一个异常。</li>
</ul>
<h2 id="75-final、finally、finalize-有什么区别？"><a href="#75-final、finally、finalize-有什么区别？" class="headerlink" title="75. final、finally、finalize 有什么区别？"></a>75. final、finally、finalize 有什么区别？</h2><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h2 id="76-try-catch-finally-中哪个部分可以省略？"><a href="#76-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="76. try-catch-finally 中哪个部分可以省略？"></a>76. try-catch-finally 中哪个部分可以省略？</h2><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<h2 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<h2 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78. 常见的异常类有哪些？"></a>78. 常见的异常类有哪些？</h2><ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 指定类不存在</li>
<li>NumberFormatException 字符串转换为数字异常</li>
<li>IndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>FileNotFoundException 文件未找到异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>IOException IO 异常</li>
<li>SocketException Socket 异常</li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79. http 响应码 301 和 302 代表的是什么？有什么区别？"></a>79. http 响应码 301 和 302 代表的是什么？有什么区别？</h2><p>301：永久重定向。</p>
<p>302：暂时重定向。</p>
<p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
<h2 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80. forward 和 redirect 的区别？"></a>80. forward 和 redirect 的区别？</h2><p>forward 是转发 和 redirect 是重定向：</p>
<ul>
<li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li>
<li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li>
<li>效率：forward 比 redirect 效率高。</li>
</ul>
<h2 id="81-简述-tcp-和-udp的区别？"><a href="#81-简述-tcp-和-udp的区别？" class="headerlink" title="81. 简述 tcp 和 udp的区别？"></a>81. 简述 tcp 和 udp的区别？</h2><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<ul>
<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>
<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>
<li>tcp 面向字节流，udp 面向报文；</li>
<li>tcp 数据传输慢，udp 数据传输快；</li>
</ul>
<h2 id="82-tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#82-tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="82. tcp 为什么要三次握手，两次不行吗？为什么？"></a>82. tcp 为什么要三次握手，两次不行吗？为什么？</h2><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>
<h2 id="83-说一下-tcp-粘包是怎么产生的？"><a href="#83-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="83. 说一下 tcp 粘包是怎么产生的？"></a>83. 说一下 tcp 粘包是怎么产生的？</h2><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>
<ul>
<li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li>
<li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li>
</ul>
<h2 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84. OSI 的七层模型都有哪些？"></a>84. OSI 的七层模型都有哪些？</h2><ul>
<li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>
<li>数据链路层：负责建立和管理节点间的链路。</li>
<li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li>
<li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li>
<li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li>
<li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li>
<li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>
</ul>
<h2 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85. get 和 post 请求有哪些区别？"></a>85. get 和 post 请求有哪些区别？</h2><ul>
<li>get 请求会被浏览器主动缓存，而 post 不会。</li>
<li>get 传递参数有大小限制，而 post 没有。</li>
<li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li>
</ul>
<h2 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86. 如何实现跨域？"></a>86. 如何实现跨域？</h2><p>实现跨域有以下几种方案：</p>
<ul>
<li>服务器端运行跨域 设置 CORS 等于 *；</li>
<li>在单个接口使用注解 @CrossOrigin 运行跨域；</li>
<li>使用 jsonp 跨域；</li>
</ul>
<h2 id="87-说一下-JSONP-实现原理？"><a href="#87-说一下-JSONP-实现原理？" class="headerlink" title="87. 说一下 JSONP 实现原理？"></a>87. 说一下 JSONP 实现原理？</h2><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="88-说一下你熟悉的设计模式？"><a href="#88-说一下你熟悉的设计模式？" class="headerlink" title="88. 说一下你熟悉的设计模式？"></a>88. 说一下你熟悉的设计模式？</h2><ul>
<li>单例模式：保证被创建一次，节省系统开销。</li>
<li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li>
<li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li>
<li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li>
<li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li>
<li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li>
</ul>
<h2 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89. 简单工厂和抽象工厂有什么区别？"></a>89. 简单工厂和抽象工厂有什么区别？</h2><ul>
<li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li>
<li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li>
<li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li>
</ul>
<h1 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h1><h2 id="90-为什么要使用-spring？"><a href="#90-为什么要使用-spring？" class="headerlink" title="90. 为什么要使用 spring？"></a>90. 为什么要使用 spring？</h2><ul>
<li>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</li>
<li>spring 提供了事务支持，使得事务操作变的更加方便。</li>
<li>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</li>
<li>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</li>
</ul>
<h2 id="91-解释一下什么是-aop？"><a href="#91-解释一下什么是-aop？" class="headerlink" title="91. 解释一下什么是 aop？"></a>91. 解释一下什么是 aop？</h2><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p>
<h2 id="92-解释一下什么是-ioc？"><a href="#92-解释一下什么是-ioc？" class="headerlink" title="92. 解释一下什么是 ioc？"></a>92. 解释一下什么是 ioc？</h2><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</p>
<p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p>
<h2 id="93-spring-有哪些主要模块？"><a href="#93-spring-有哪些主要模块？" class="headerlink" title="93. spring 有哪些主要模块？"></a>93. spring 有哪些主要模块？</h2><ul>
<li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</li>
<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>
<li>spring dao：Data Access Object 提供了JDBC的抽象层。</li>
<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>
<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>
<li>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</li>
</ul>
<h2 id="94-spring-常用的注入方式有哪些？"><a href="#94-spring-常用的注入方式有哪些？" class="headerlink" title="94. spring 常用的注入方式有哪些？"></a>94. spring 常用的注入方式有哪些？</h2><ul>
<li>setter 属性注入</li>
<li>构造方法注入</li>
<li>注解方式注入</li>
</ul>
<h2 id="95-spring-中的-bean-是线程安全的吗？"><a href="#95-spring-中的-bean-是线程安全的吗？" class="headerlink" title="95. spring 中的 bean 是线程安全的吗？"></a>95. spring 中的 bean 是线程安全的吗？</h2><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<ul>
<li>有状态就是有数据存储功能。</li>
<li>无状态就是不会保存数据。</li>
</ul>
<h2 id="96-spring-支持几种-bean-的作用域？"><a href="#96-spring-支持几种-bean-的作用域？" class="headerlink" title="96. spring 支持几种 bean 的作用域？"></a>96. spring 支持几种 bean 的作用域？</h2><p>spring 支持 5 种作用域，如下：</p>
<ul>
<li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li>
<li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li>
<li>Web 环境下的作用域：</li>
<li>request：每次 http 请求都会创建一个 bean；</li>
<li>session：同一个 http session 共享一个 bean 实例；</li>
<li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。<br>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</li>
</ul>
<h2 id="97-spring-自动装配-bean-有哪些方式？"><a href="#97-spring-自动装配-bean-有哪些方式？" class="headerlink" title="97. spring 自动装配 bean 有哪些方式？"></a>97. spring 自动装配 bean 有哪些方式？</h2><ul>
<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>
<li>byName：它根据 bean 的名称注入对象依赖项。</li>
<li>byType：它根据类型注入对象依赖项。</li>
<li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li>
<li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li>
</ul>
<h2 id="98-spring-事务实现方式有哪些？"><a href="#98-spring-事务实现方式有哪些？" class="headerlink" title="98. spring 事务实现方式有哪些？"></a>98. spring 事务实现方式有哪些？</h2><p>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。<br>编码方式：提供编码的形式管理和维护事务。</p>
<h2 id="99-说一下-spring-的事务隔离？"><a href="#99-说一下-spring-的事务隔离？" class="headerlink" title="99. 说一下 spring 的事务隔离？"></a>99. 说一下 spring 的事务隔离？</h2><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<ul>
<li><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
</li>
<li><p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
</li>
<li><p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
</li>
<li><p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
</li>
<li><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
</li>
</ul>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h2 id="100-说一下-spring-mvc-运行流程？"><a href="#100-说一下-spring-mvc-运行流程？" class="headerlink" title="100. 说一下 spring mvc 运行流程？"></a>100. 说一下 spring mvc 运行流程？</h2><ul>
<li>spring mvc 先将请求发送给 DispatcherServlet。</li>
<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>
<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>
<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>
<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>
<li>视图对象负责渲染返回给客户端。</li>
</ul>
<h2 id="101-spring-mvc-有哪些组件？"><a href="#101-spring-mvc-有哪些组件？" class="headerlink" title="101. spring mvc 有哪些组件？"></a>101. spring mvc 有哪些组件？</h2><ul>
<li>前置控制器 DispatcherServlet。</li>
<li>映射控制器 HandlerMapping。</li>
<li>处理器 Controller。</li>
<li>模型和视图 ModelAndView。</li>
<li>视图解析器 ViewResolver。</li>
</ul>
<h2 id="102-RequestMapping-的作用是什么？"><a href="#102-RequestMapping-的作用是什么？" class="headerlink" title="102. @RequestMapping 的作用是什么？"></a>102. @RequestMapping 的作用是什么？</h2><p>将 http 请求映射到相应的类/方法上。</p>
<h2 id="103-Autowired-的作用是什么？"><a href="#103-Autowired-的作用是什么？" class="headerlink" title="103. @Autowired 的作用是什么？"></a>103. @Autowired 的作用是什么？</h2><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p>
<h1 id="Spring-Boot-Spring-Cloud"><a href="#Spring-Boot-Spring-Cloud" class="headerlink" title="Spring Boot/Spring Cloud"></a>Spring Boot/Spring Cloud</h1><h2 id="104-什么是-spring-boot？"><a href="#104-什么是-spring-boot？" class="headerlink" title="104. 什么是 spring boot？"></a>104. 什么是 spring boot？</h2><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p>
<h2 id="105-为什么要用-spring-boot？"><a href="#105-为什么要用-spring-boot？" class="headerlink" title="105. 为什么要用 spring boot？"></a>105. 为什么要用 spring boot？</h2><ul>
<li>配置简单</li>
<li>独立运行</li>
<li>自动装配</li>
<li>无代码生成和 xml 配置</li>
<li>提供应用监控</li>
<li>易上手</li>
<li>提升开发效率</li>
</ul>
<h2 id="106-spring-boot-核心配置文件是什么？"><a href="#106-spring-boot-核心配置文件是什么？" class="headerlink" title="106. spring boot 核心配置文件是什么？"></a>106. spring boot 核心配置文件是什么？</h2><p>spring boot 核心的两个配置文件：</p>
<ul>
<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li>
<li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li>
</ul>
<h2 id="107-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#107-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="107. spring boot 配置文件有哪几种类型？它们有什么区别？"></a>107. spring boot 配置文件有哪几种类型？它们有什么区别？</h2><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</p>
<p>. properties 配置如下：<br><code>spring. RabbitMQ. port=5672</code><br>. yml 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    RabbitMQ:</span><br><span class="line">        port: 5672</span><br></pre></td></tr></table></figure>
<p>. yml 格式不支持 @PropertySource 注解导入。</p>
<h2 id="108-spring-boot-有哪些方式可以实现热部署？"><a href="#108-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="108. spring boot 有哪些方式可以实现热部署？"></a>108. spring boot 有哪些方式可以实现热部署？</h2><p>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</p>
<h2 id="109-jpa-和-hibernate-有什么区别？"><a href="#109-jpa-和-hibernate-有什么区别？" class="headerlink" title="109. jpa 和 hibernate 有什么区别？"></a>109. jpa 和 hibernate 有什么区别？</h2><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p>
<h2 id="110-什么是-spring-cloud？"><a href="#110-什么是-spring-cloud？" class="headerlink" title="110. 什么是 spring cloud？"></a>110. 什么是 spring cloud？</h2><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>
<h2 id="111-spring-cloud-断路器的作用是什么？"><a href="#111-spring-cloud-断路器的作用是什么？" class="headerlink" title="111. spring cloud 断路器的作用是什么？"></a>111. spring cloud 断路器的作用是什么？</h2><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h2 id="112-spring-cloud-的核心组件有哪些？"><a href="#112-spring-cloud-的核心组件有哪些？" class="headerlink" title="112. spring cloud 的核心组件有哪些？"></a>112. spring cloud 的核心组件有哪些？</h2><ul>
<li>Eureka：服务注册于发现。</li>
<li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li>
<li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li>
<li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>
<li>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li>
</ul>
<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><h2 id="113-为什么要使用-hibernate？"><a href="#113-为什么要使用-hibernate？" class="headerlink" title="113. 为什么要使用 hibernate？"></a>113. 为什么要使用 hibernate？</h2><ul>
<li>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</li>
<li>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</li>
<li>可以很方便的进行数据库的移植工作。</li>
<li>提供了缓存机制，是程序执行更改的高效。</li>
</ul>
<h2 id="114-什么是-ORM-框架？"><a href="#114-什么是-ORM-框架？" class="headerlink" title="114. 什么是 ORM 框架？"></a>114. 什么是 ORM 框架？</h2><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p>
<p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p>
<h2 id="115-hibernate-中如何在控制台查看打印的-SQL-语句？"><a href="#115-hibernate-中如何在控制台查看打印的-SQL-语句？" class="headerlink" title="115. hibernate 中如何在控制台查看打印的 SQL 语句？"></a>115. hibernate 中如何在控制台查看打印的 SQL 语句？</h2><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p>
<h2 id="116-hibernate-有几种查询方式？"><a href="#116-hibernate-有几种查询方式？" class="headerlink" title="116. hibernate 有几种查询方式？"></a>116. hibernate 有几种查询方式？</h2><p>三种：hql、原生 SQL、条件查询 Criteria。</p>
<h2 id="117-hibernate-实体类可以被定义为-final-吗？"><a href="#117-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="117. hibernate 实体类可以被定义为 final 吗？"></a>117. hibernate 实体类可以被定义为 final 吗？</h2><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p>
<h2 id="118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p>
<h2 id="119-hibernate-是如何工作的？"><a href="#119-hibernate-是如何工作的？" class="headerlink" title="119. hibernate 是如何工作的？"></a>119. hibernate 是如何工作的？</h2><ul>
<li>读取并解析配置文件。</li>
<li>读取并解析映射文件，创建 SessionFactory。</li>
<li>打开 Session。</li>
<li>创建事务。</li>
<li>进行持久化操作。</li>
<li>提交事务。</li>
<li>关闭 Session。</li>
<li>关闭 SessionFactory。</li>
</ul>
<h2 id="120-get-和-load-的区别？"><a href="#120-get-和-load-的区别？" class="headerlink" title="120. get()和 load()的区别？"></a>120. get()和 load()的区别？</h2><ul>
<li>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。</li>
<li>load()支持延迟加载；get() 不支持延迟加载。</li>
</ul>
<h2 id="121-说一下-hibernate-的缓存机制？"><a href="#121-说一下-hibernate-的缓存机制？" class="headerlink" title="121. 说一下 hibernate 的缓存机制？"></a>121. 说一下 hibernate 的缓存机制？</h2><p>hibernate 常用的缓存有一级缓存和二级缓存：</p>
<p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</p>
<p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p>
<h2 id="122-hibernate-对象有哪些状态？"><a href="#122-hibernate-对象有哪些状态？" class="headerlink" title="122. hibernate 对象有哪些状态？"></a>122. hibernate 对象有哪些状态？</h2><ul>
<li>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</li>
<li>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。</li>
<li>游离状态：Session 关闭之后对象就是游离状态。</li>
</ul>
<h2 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h2><ul>
<li>getCurrentSession 会绑定当前线程，而 openSession 则不会。</li>
<li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</li>
</ul>
<h2 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#124-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="124. hibernate 实体类必须要有无参构造函数吗？为什么？"></a>124. hibernate 实体类必须要有无参构造函数吗？为什么？</h2><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="125-MyBatis-中-和-的区别是什么？"><a href="#125-MyBatis-中-和-的区别是什么？" class="headerlink" title="125. MyBatis 中 #{}和 ${}的区别是什么？"></a>125. MyBatis 中 #{}和 ${}的区别是什么？</h2><p><code>\#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符替换。 在使用<code> #&#123;&#125;</code>时，MyBatis 会将 SQL 中的<code> #&#123;&#125;</code>替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p>
<h2 id="126-MyBatis-有几种分页方式？"><a href="#126-MyBatis-有几种分页方式？" class="headerlink" title="126. MyBatis 有几种分页方式？"></a>126. MyBatis 有几种分页方式？</h2><ul>
<li><p>分页方式：逻辑分页和物理分页。</p>
</li>
<li><p>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p>
</li>
<li><p>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>
</li>
</ul>
<h2 id="127-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#127-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="127. RowBounds 是一次性查询全部结果吗？为什么？"></a>127. RowBounds 是一次性查询全部结果吗？为什么？</h2><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>
<p>Fetch Size 官方相关文档：<a href="http://t/">http://t</a>. cn/EfSE2g3</p>
<h2 id="128-MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#128-MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="128. MyBatis 逻辑分页和物理分页的区别是什么？"></a>128. MyBatis 逻辑分页和物理分页的区别是什么？</h2><ul>
<li>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</li>
<li>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</li>
</ul>
<h2 id="129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="129. MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a>129. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h2><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p>
<p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>
<h2 id="130-说一下-MyBatis-的一级缓存和二级缓存？"><a href="#130-说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="130. 说一下 MyBatis 的一级缓存和二级缓存？"></a>130. 说一下 MyBatis 的一级缓存和二级缓存？</h2><ul>
<li>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</li>
<li>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</li>
</ul>
<p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h2 id="131-MyBatis-和-hibernate-的区别有哪些？"><a href="#131-MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="131. MyBatis 和 hibernate 的区别有哪些？"></a>131. MyBatis 和 hibernate 的区别有哪些？</h2><ul>
<li>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</li>
<li>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</li>
<li>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</li>
<li>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</li>
</ul>
<h2 id="132-MyBatis-有哪些执行器（Executor）？"><a href="#132-MyBatis-有哪些执行器（Executor）？" class="headerlink" title="132. MyBatis 有哪些执行器（Executor）？"></a>132. MyBatis 有哪些执行器（Executor）？</h2><p>MyBatis 有三种基本的Executor执行器：</p>
<ul>
<li>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</li>
<li>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</li>
<li>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</li>
</ul>
<h2 id="133-MyBatis-分页插件的实现原理是什么？"><a href="#133-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="133. MyBatis 分页插件的实现原理是什么？"></a>133. MyBatis 分页插件的实现原理是什么？</h2><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h2 id="134-MyBatis-如何编写一个自定义插件？"><a href="#134-MyBatis-如何编写一个自定义插件？" class="headerlink" title="134. MyBatis 如何编写一个自定义插件？"></a>134. MyBatis 如何编写一个自定义插件？</h2><p><strong>自定义插件实现原理</strong></p>
<p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p>
<ul>
<li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</li>
<li>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</li>
<li>ParameterHandler：拦截参数的处理；</li>
<li>ResultSetHandler：拦截结果集的处理。</li>
<li><em>自定义插件实现关键</em>*</li>
</ul>
<p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Interceptor &#123;   </span><br><span class="line">   Object intercept(Invocation invocation) throws Throwable;       </span><br><span class="line">   Object plugin(Object target);    </span><br><span class="line">   void setProperties(Properties properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</li>
<li>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；</li>
<li>intercept 方法就是要进行拦截的时候要执行的方法。</li>
<li><em>自定义插件实现示例</em>*</li>
</ul>
<p>官方插件实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Intercepts(&#123;@Signature(type = Executor. class, method = &quot;query&quot;,</span><br><span class="line">        args = &#123;MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class&#125;)&#125;)</span><br><span class="line">public class TestInterceptor implements Interceptor &#123;</span><br><span class="line">   public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">     Object target = invocation. getTarget(); //被代理对象</span><br><span class="line">     Method method = invocation. getMethod(); //代理方法</span><br><span class="line">     Object[] args = invocation. getArgs(); //方法参数</span><br><span class="line">     // do something . . . . . .  方法拦截前执行代码块</span><br><span class="line">     Object result = invocation. proceed();</span><br><span class="line">     // do something . . . . . . . 方法拦截后执行代码块</span><br><span class="line">     return result;</span><br><span class="line">   &#125;</span><br><span class="line">   public Object plugin(Object target) &#123;</span><br><span class="line">     return Plugin. wrap(target, this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="135-RabbitMQ-的使用场景有哪些？"><a href="#135-RabbitMQ-的使用场景有哪些？" class="headerlink" title="135. RabbitMQ 的使用场景有哪些？"></a>135. RabbitMQ 的使用场景有哪些？</h2><ul>
<li>抢购活动，削峰填谷，防止系统崩塌。</li>
<li>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</li>
<li>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</li>
</ul>
<h2 id="136-RabbitMQ-有哪些重要的角色？"><a href="#136-RabbitMQ-有哪些重要的角色？" class="headerlink" title="136. RabbitMQ 有哪些重要的角色？"></a>136. RabbitMQ 有哪些重要的角色？</h2><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p>
<ul>
<li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li>
<li>消费者：消息的接收方，用于处理数据和确认消息；</li>
<li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li>
</ul>
<h2 id="137-RabbitMQ-有哪些重要的组件？"><a href="#137-RabbitMQ-有哪些重要的组件？" class="headerlink" title="137. RabbitMQ 有哪些重要的组件？"></a>137. RabbitMQ 有哪些重要的组件？</h2><ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li>
<li>Channel（信道）：消息推送使用的通道。</li>
<li>Exchange（交换器）：用于接受、分配消息。</li>
<li>Queue（队列）：用于存储生产者的消息。</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
</ul>
<h2 id="138-RabbitMQ-中-vhost-的作用是什么？"><a href="#138-RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="138. RabbitMQ 中 vhost 的作用是什么？"></a>138. RabbitMQ 中 vhost 的作用是什么？</h2><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p>
<h2 id="139-RabbitMQ-的消息是怎么发送的？"><a href="#139-RabbitMQ-的消息是怎么发送的？" class="headerlink" title="139. RabbitMQ 的消息是怎么发送的？"></a>139. RabbitMQ 的消息是怎么发送的？</h2><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
<h2 id="140-RabbitMQ-怎么保证消息的稳定性？"><a href="#140-RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="140. RabbitMQ 怎么保证消息的稳定性？"></a>140. RabbitMQ 怎么保证消息的稳定性？</h2><ul>
<li>提供了事务的功能。</li>
<li>通过将 channel 设置为 confirm（确认）模式。</li>
</ul>
<h2 id="141-RabbitMQ-怎么避免消息丢失？"><a href="#141-RabbitMQ-怎么避免消息丢失？" class="headerlink" title="141. RabbitMQ 怎么避免消息丢失？"></a>141. RabbitMQ 怎么避免消息丢失？</h2><ul>
<li>把消息持久化磁盘，保证服务器重启消息不丢失。</li>
<li>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li>
</ul>
<h2 id="142-要保证消息持久化成功的条件有哪些？"><a href="#142-要保证消息持久化成功的条件有哪些？" class="headerlink" title="142. 要保证消息持久化成功的条件有哪些？"></a>142. 要保证消息持久化成功的条件有哪些？</h2><ul>
<li>声明队列必须设置持久化 durable 设置为 true.</li>
<li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li>
<li>消息已经到达持久化交换器。</li>
<li>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。</li>
</ul>
<h2 id="143-RabbitMQ-持久化有什么缺点？"><a href="#143-RabbitMQ-持久化有什么缺点？" class="headerlink" title="143. RabbitMQ 持久化有什么缺点？"></a>143. RabbitMQ 持久化有什么缺点？</h2><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>
<h2 id="144-RabbitMQ-有几种广播类型？"><a href="#144-RabbitMQ-有几种广播类型？" class="headerlink" title="144. RabbitMQ 有几种广播类型？"></a>144. RabbitMQ 有几种广播类型？</h2><ul>
<li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</li>
<li>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</li>
<li>fanout：分发模式，把消费分发给所有订阅者。</li>
<li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</li>
</ul>
<h2 id="145-RabbitMQ-怎么实现延迟消息队列？"><a href="#145-RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="145. RabbitMQ 怎么实现延迟消息队列？"></a>145. RabbitMQ 怎么实现延迟消息队列？</h2><p>延迟队列的实现有两种方式：</p>
<ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li>
<li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li>
</ul>
<h2 id="146-RabbitMQ-集群有什么用？"><a href="#146-RabbitMQ-集群有什么用？" class="headerlink" title="146. RabbitMQ 集群有什么用？"></a>146. RabbitMQ 集群有什么用？</h2><p>集群主要有以下两个用途：</p>
<ul>
<li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li>
<li>高容量：集群可以承载更多的消息量。</li>
</ul>
<h2 id="147-RabbitMQ-节点的类型有哪些？"><a href="#147-RabbitMQ-节点的类型有哪些？" class="headerlink" title="147. RabbitMQ 节点的类型有哪些？"></a>147. RabbitMQ 节点的类型有哪些？</h2><ul>
<li>磁盘节点：消息会存储到磁盘。</li>
<li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
</ul>
<h2 id="148-RabbitMQ-集群搭建需要注意哪些问题？"><a href="#148-RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="148. RabbitMQ 集群搭建需要注意哪些问题？"></a>148. RabbitMQ 集群搭建需要注意哪些问题？</h2><ul>
<li>各节点之间使用“–link”连接，此属性不能忽略。</li>
<li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li>
<li>整个集群中必须包含一个磁盘节点。</li>
</ul>
<h2 id="149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="149. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>149. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p>
<ul>
<li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li>
<li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li>
</ul>
<h2 id="150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="150. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>150. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</li>
</ul>
<h2 id="151-RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#151-RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="151. RabbitMQ 对集群节点停止顺序有要求吗？"></a>151. RabbitMQ 对集群节点停止顺序有要求吗？</h2><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="152-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#152-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="152. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>152. kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>
<h2 id="153-kafka-有几种数据保留的策略？"><a href="#153-kafka-有几种数据保留的策略？" class="headerlink" title="153. kafka 有几种数据保留的策略？"></a>153. kafka 有几种数据保留的策略？</h2><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>
<h2 id="154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？"><a href="#154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？" class="headerlink" title="154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a>154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h2><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>
<h2 id="155-什么情况会导致-kafka-运行变慢？"><a href="#155-什么情况会导致-kafka-运行变慢？" class="headerlink" title="155. 什么情况会导致 kafka 运行变慢？"></a>155. 什么情况会导致 kafka 运行变慢？</h2><ul>
<li>cpu 性能瓶颈</li>
<li>磁盘读写瓶颈</li>
<li>网络瓶颈</li>
</ul>
<h2 id="156-使用-kafka-集群需要注意什么？"><a href="#156-使用-kafka-集群需要注意什么？" class="headerlink" title="156. 使用 kafka 集群需要注意什么？"></a>156. 使用 kafka 集群需要注意什么？</h2><ul>
<li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li>
<li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li>
</ul>
<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="157-zookeeper-是什么？"><a href="#157-zookeeper-是什么？" class="headerlink" title="157. zookeeper 是什么？"></a>157. zookeeper 是什么？</h2><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h2 id="158-zookeeper-都有哪些功能？"><a href="#158-zookeeper-都有哪些功能？" class="headerlink" title="158. zookeeper 都有哪些功能？"></a>158. zookeeper 都有哪些功能？</h2><ul>
<li>集群管理：监控节点存活状态、运行请求等。</li>
<li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li>
<li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li>
<li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li>
</ul>
<h2 id="159-zookeeper-有几种部署模式？"><a href="#159-zookeeper-有几种部署模式？" class="headerlink" title="159. zookeeper 有几种部署模式？"></a>159. zookeeper 有几种部署模式？</h2><p>zookeeper 有三种部署模式：</p>
<ul>
<li>单机部署：一台集群上运行；</li>
<li>集群部署：多台集群运行；</li>
<li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li>
</ul>
<h2 id="160-zookeeper-怎么保证主从节点的状态同步？"><a href="#160-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="160. zookeeper 怎么保证主从节点的状态同步？"></a>160. zookeeper 怎么保证主从节点的状态同步？</h2><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<h2 id="161-集群中为什么要有主节点？"><a href="#161-集群中为什么要有主节点？" class="headerlink" title="161. 集群中为什么要有主节点？"></a>161. 集群中为什么要有主节点？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>
<h2 id="162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h2><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>
<h2 id="163-说一下-zookeeper-的通知机制？"><a href="#163-说一下-zookeeper-的通知机制？" class="headerlink" title="163. 说一下 zookeeper 的通知机制？"></a>163. 说一下 zookeeper 的通知机制？</h2><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="164-数据库的三范式是什么？"><a href="#164-数据库的三范式是什么？" class="headerlink" title="164. 数据库的三范式是什么？"></a>164. 数据库的三范式是什么？</h2><ul>
<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>
<li>第三范式：任何非主属性不依赖于其它非主属性。</li>
</ul>
<h2 id="165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？"><a href="#165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a>165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</h2><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h2 id="166-如何获取当前数据库版本？"><a href="#166-如何获取当前数据库版本？" class="headerlink" title="166. 如何获取当前数据库版本？"></a>166. 如何获取当前数据库版本？</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h2 id="167-说一下-ACID-是什么？"><a href="#167-说一下-ACID-是什么？" class="headerlink" title="167. 说一下 ACID 是什么？"></a>167. 说一下 ACID 是什么？</h2><ul>
<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h2 id="168-char-和-varchar-的区别是什么？"><a href="#168-char-和-varchar-的区别是什么？" class="headerlink" title="168. char 和 varchar 的区别是什么？"></a>168. char 和 varchar 的区别是什么？</h2><ul>
<li><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
</li>
<li><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
</li>
</ul>
<h2 id="169-float-和-double-的区别是什么？"><a href="#169-float-和-double-的区别是什么？" class="headerlink" title="169. float 和 double 的区别是什么？"></a>169. float 和 double 的区别是什么？</h2><ul>
<li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li>
<li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li>
</ul>
<h2 id="170-MySQL-的内连接、左连接、右连接有什么区别？"><a href="#170-MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="170. MySQL 的内连接、左连接、右连接有什么区别？"></a>170. MySQL 的内连接、左连接、右连接有什么区别？</h2><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h2 id="171-MySQL-索引是怎么实现的？"><a href="#171-MySQL-索引是怎么实现的？" class="headerlink" title="171. MySQL 索引是怎么实现的？"></a>171. MySQL 索引是怎么实现的？</h2><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h2 id="172-怎么验证-MySQL-的索引是否满足需求？"><a href="#172-怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="172. 怎么验证 MySQL 的索引是否满足需求？"></a>172. 怎么验证 MySQL 的索引是否满足需求？</h2><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from table where type=1。</p>
<h2 id="173-说一下数据库的事务隔离？"><a href="#173-说一下数据库的事务隔离？" class="headerlink" title="173. 说一下数据库的事务隔离？"></a>173. 说一下数据库的事务隔离？</h2><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：<br><code>transaction-isolation = REPEATABLE-READ</code><br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<ul>
<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>
<li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li>
<li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li>
<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>
<li><em>脏读</em>* ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</li>
</ul>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h2 id="174-说一下-MySQL-常用的引擎？"><a href="#174-说一下-MySQL-常用的引擎？" class="headerlink" title="174. 说一下 MySQL 常用的引擎？"></a>174. 说一下 MySQL 常用的引擎？</h2><ul>
<li><p>InnoDB 引擎：MySQL 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>
</li>
<li><p>MyISAM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyISAM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MySQL 作为数据库引擎的首选。</p>
</li>
</ul>
<h2 id="175-说一下-MySQL-的行锁和表锁？"><a href="#175-说一下-MySQL-的行锁和表锁？" class="headerlink" title="175. 说一下 MySQL 的行锁和表锁？"></a>175. 说一下 MySQL 的行锁和表锁？</h2><p>MySQL 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<ul>
<li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li>
</ul>
<h2 id="176-说一下乐观锁和悲观锁？"><a href="#176-说一下乐观锁和悲观锁？" class="headerlink" title="176. 说一下乐观锁和悲观锁？"></a>176. 说一下乐观锁和悲观锁？</h2><ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。<br>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</li>
</ul>
<h2 id="177-MySQL-问题排查都有哪些手段？"><a href="#177-MySQL-问题排查都有哪些手段？" class="headerlink" title="177. MySQL 问题排查都有哪些手段？"></a>177. MySQL 问题排查都有哪些手段？</h2><ul>
<li>使用 show processlist 命令查看当前所有连接信息。</li>
<li>使用 explain 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h2 id="178-如何做-MySQL-的性能优化？"><a href="#178-如何做-MySQL-的性能优化？" class="headerlink" title="178. 如何做 MySQL 的性能优化？"></a>178. 如何做 MySQL 的性能优化？</h2><ul>
<li>为搜索字段创建索引。</li>
<li>避免使用 select *，列出需要查询的字段。</li>
<li>垂直分割分表。</li>
<li>选择正确的存储引擎。</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="179-Redis-是什么？都有哪些使用场景？"><a href="#179-Redis-是什么？都有哪些使用场景？" class="headerlink" title="179. Redis 是什么？都有哪些使用场景？"></a>179. Redis 是什么？都有哪些使用场景？</h2><p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p>
<p>Redis 使用场景：</p>
<ul>
<li>记录帖子点赞数、点击数、评论数；</li>
<li>缓存近期热帖；</li>
<li>缓存文章详情信息；</li>
<li>记录用户会话信息。</li>
</ul>
<h2 id="180-Redis-有哪些功能？"><a href="#180-Redis-有哪些功能？" class="headerlink" title="180. Redis 有哪些功能？"></a>180. Redis 有哪些功能？</h2><ul>
<li>数据缓存功能</li>
<li>分布式锁的功能</li>
<li>支持数据持久化</li>
<li>支持事务</li>
<li>支持消息队列</li>
</ul>
<h2 id="181-Redis-和-memcache-有什么区别？"><a href="#181-Redis-和-memcache-有什么区别？" class="headerlink" title="181. Redis 和 memcache 有什么区别？"></a>181. Redis 和 memcache 有什么区别？</h2><ul>
<li>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</li>
<li>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</li>
<li>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
<li>value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。</li>
</ul>
<h2 id="182-Redis-为什么是单线程的？"><a href="#182-Redis-为什么是单线程的？" class="headerlink" title="182. Redis 为什么是单线程的？"></a>182. Redis 为什么是单线程的？</h2><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>
<h2 id="183-什么是缓存穿透？怎么解决？"><a href="#183-什么是缓存穿透？怎么解决？" class="headerlink" title="183. 什么是缓存穿透？怎么解决？"></a>183. 什么是缓存穿透？怎么解决？</h2><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h2 id="184-Redis-支持的数据类型有哪些？"><a href="#184-Redis-支持的数据类型有哪些？" class="headerlink" title="184. Redis 支持的数据类型有哪些？"></a>184. Redis 支持的数据类型有哪些？</h2><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p>
<h2 id="185-Redis-支持的-Java-客户端都有哪些？"><a href="#185-Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="185. Redis 支持的 Java 客户端都有哪些？"></a>185. Redis 支持的 Java 客户端都有哪些？</h2><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p>
<h2 id="186-jedis-和-Redisson-有哪些区别？"><a href="#186-jedis-和-Redisson-有哪些区别？" class="headerlink" title="186. jedis 和 Redisson 有哪些区别？"></a>186. jedis 和 Redisson 有哪些区别？</h2><ul>
<li>jedis：提供了比较全面的 Redis 命令的支持。</li>
<li>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</li>
</ul>
<h2 id="187-怎么保证缓存和数据库数据的一致性？"><a href="#187-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="187. 怎么保证缓存和数据库数据的一致性？"></a>187. 怎么保证缓存和数据库数据的一致性？</h2><p>合理设置缓存的过期时间。<br>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p>
<h2 id="188-Redis-持久化有几种方式？"><a href="#188-Redis-持久化有几种方式？" class="headerlink" title="188. Redis 持久化有几种方式？"></a>188. Redis 持久化有几种方式？</h2><p>Redis 的持久化有两种方式，或者说有两种策略：</p>
<ul>
<li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li>
</ul>
<h2 id="189-Redis-怎么实现分布式锁？"><a href="#189-Redis-怎么实现分布式锁？" class="headerlink" title="189. Redis 怎么实现分布式锁？"></a>189. Redis 怎么实现分布式锁？</h2><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>
<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>
<h2 id="190-Redis-分布式锁有什么缺陷？"><a href="#190-Redis-分布式锁有什么缺陷？" class="headerlink" title="190. Redis 分布式锁有什么缺陷？"></a>190. Redis 分布式锁有什么缺陷？</h2><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<h2 id="191-Redis-如何做内存优化？"><a href="#191-Redis-如何做内存优化？" class="headerlink" title="191. Redis 如何做内存优化？"></a>191. Redis 如何做内存优化？</h2><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p>
<h2 id="192-Redis-淘汰策略有哪些？"><a href="#192-Redis-淘汰策略有哪些？" class="headerlink" title="192. Redis 淘汰策略有哪些？"></a>192. Redis 淘汰策略有哪些？</h2><ul>
<li><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p>
</li>
<li><p>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p>
</li>
<li><p>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p>
</li>
<li><p>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p>
</li>
<li><p>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</p>
</li>
<li><p>no-enviction（驱逐）：禁止驱逐数据。</p>
</li>
</ul>
<h2 id="193-Redis-常见的性能问题有哪些？该如何解决？"><a href="#193-Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="193. Redis 常见的性能问题有哪些？该如何解决？"></a>193. Redis 常见的性能问题有哪些？该如何解决？</h2><ul>
<li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li>
<li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="194-说一下-JVM-的主要组成部分？及其作用？"><a href="#194-说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="194. 说一下 JVM 的主要组成部分？及其作用？"></a>194. 说一下 JVM 的主要组成部分？及其作用？</h2><ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
<li>*组件的作用**： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</li>
</ul>
<h2 id="195-说一下-JVM-运行时数据区？"><a href="#195-说一下-JVM-运行时数据区？" class="headerlink" title="195. 说一下 JVM 运行时数据区？"></a>195. 说一下 JVM 运行时数据区？</h2><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<ul>
<li><p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p>
</li>
<li><p>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p>
</li>
<li><p>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p>
</li>
<li><p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</p>
</li>
<li><p>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>
</li>
</ul>
<h2 id="196-说一下堆栈的区别？"><a href="#196-说一下堆栈的区别？" class="headerlink" title="196. 说一下堆栈的区别？"></a>196. 说一下堆栈的区别？</h2><ul>
<li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li>
<li>共享性：堆是线程共享的，栈是线程私有的。</li>
<li>空间大小：堆大小远远大于栈。</li>
</ul>
<h2 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197. 队列和栈是什么？有什么区别？"></a>197. 队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。</p>
<p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p>
<p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
<h2 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198. 什么是双亲委派模型？"></a>198. 什么是双亲委派模型？</h2><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>其他类加载器：</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</li>
</ul>
<h2 id="199-说一下类装载的执行过程？"><a href="#199-说一下类装载的执行过程？" class="headerlink" title="199. 说一下类装载的执行过程？"></a>199. 说一下类装载的执行过程？</h2><p>类装载分为以下 5 个步骤：</p>
<ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ul>
<h2 id="200-怎么判断对象是否可以被回收？"><a href="#200-怎么判断对象是否可以被回收？" class="headerlink" title="200. 怎么判断对象是否可以被回收？"></a>200. 怎么判断对象是否可以被回收？</h2><p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h2 id="201-Java-中都有哪些引用类型？"><a href="#201-Java-中都有哪些引用类型？" class="headerlink" title="201. Java 中都有哪些引用类型？"></a>201. Java 中都有哪些引用类型？</h2><ul>
<li>强引用：发生 gc 的时候不会被回收。</li>
<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>
<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li>
</ul>
<h2 id="202-说一下-JVM-有哪些垃圾回收算法？"><a href="#202-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="202. 说一下 JVM 有哪些垃圾回收算法？"></a>202. 说一下 JVM 有哪些垃圾回收算法？</h2><ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li>
</ul>
<h2 id="203-说一下-JVM-有哪些垃圾回收器？"><a href="#203-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="203. 说一下 JVM 有哪些垃圾回收器？"></a>203. 说一下 JVM 有哪些垃圾回收器？</h2><ul>
<li>Serial：最早的单线程串行垃圾回收器。</li>
<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>
<li>ParNew：是 Serial 的多线程版本。</li>
<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>
<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li>
<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li>
<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>
</ul>
<h2 id="204-详细介绍一下-CMS-垃圾回收器？"><a href="#204-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="204. 详细介绍一下 CMS 垃圾回收器？"></a>204. 详细介绍一下 CMS 垃圾回收器？</h2><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h2 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li>
</ul>
<h2 id="206-简述分代垃圾回收器是怎么工作的？"><a href="#206-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="206. 简述分代垃圾回收器是怎么工作的？"></a>206. 简述分代垃圾回收器是怎么工作的？</h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</li>
</ul>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h2 id="207-说一下-JVM-调优的工具？"><a href="#207-说一下-JVM-调优的工具？" class="headerlink" title="207. 说一下 JVM 调优的工具？"></a>207. 说一下 JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<h2 id="208-常用的-JVM-调优的参数都有哪些？"><a href="#208-常用的-JVM-调优的参数都有哪些？" class="headerlink" title="208. 常用的 JVM 调优的参数都有哪些？"></a>208. 常用的 JVM 调优的参数都有哪些？</h2><ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>devops-sentinel测试环境异常停止复盘</title>
    <url>/2020/08/05/devops-sentinel%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E5%BC%82%E5%B8%B8%E5%81%9C%E6%AD%A2%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h1 id="一-异常状况"><a href="#一-异常状况" class="headerlink" title="一. 异常状况"></a>一. 异常状况</h1><p>日志停止，不再有新日志产生。<br>influxDB中无新数据写入。</p>
<h1 id="二-问题分析-amp-解决"><a href="#二-问题分析-amp-解决" class="headerlink" title="二. 问题分析&amp;解决"></a>二. 问题分析&amp;解决</h1><ol>
<li><p>系统结构<br> 系统主要分为两个任务，sla量测点健康检查和应用健康检查。两个任务分别通过两个定时任务每分钟启动一次，定时任务是生产者，获取待消费的Entity放入一个容量为1的阻塞队列。<br> 该系统为生产者消费者模式，分别通容量为1的阻塞队列来传递Entity。</p>
 <span id="more"></span></li>
<li><p>问题分析<br> <strong>通过jstack日志分析当前所有线程状态。</strong><br><img src="/image/jstack%E6%97%A5%E5%BF%97.png" alt="jstack日志"></p>
<p> 可以看到jstack日志中，quartz定时任务的默认十个线程都卡在SLA的生产者环节，相当于说sla部分的阻塞队列中有一个Entity，导致生产者不能放入Entity，而生产者不能放入时会等待阻塞队列被消费，所以会一直占有quartz线程。<br> 而quartz定时任务每分钟会执行一次，相当于每分钟有一个新的SLA生产者等待阻塞队列。十分钟后当quartz的默认10个线程被全部占用后，就不会再有新的定时任务被执行了。所以导致没有新的日志产生。<br> （该问题从日志中也可以分析出来，定时任务sla启动的log有20次，而执行完成的log只有10次，说明有10个sla的quartz任务还在占有着线程）</p>
<p> <strong>分析出了为什么没有日志产生后，继续分析为什么sla的阻塞队列中的Entity没有被消费者及时消费。</strong><br> sla的消费者是一个10个线程的线程池，10个线程同时去消费阻塞队列。消费整个流程如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        // 获取任务，没有任务时会阻塞</span><br><span class="line">                        UrlEntity urlEntity = getUrlEntity();</span><br><span class="line">                        if (urlEntity != null) &#123;</span><br><span class="line">                            CheckRespEntity checkRespEntity = doHealthCheck(urlEntity);</span><br><span class="line">                            // 调用健康检查接口，把调用的结果保留在healthCheckModel对象中</span><br><span class="line">                            checkRespEntity = buildInfluxEntity(checkRespEntity);</span><br><span class="line">                            // 将健康检查结果写入influxDb</span><br><span class="line">                            toInfluxDB(monitorProxy, checkRespEntity);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>


<p><strong>如果在消费过程中有异常抛出未捕获的话，那么该线程会在抛出异常后死掉而不会影响其他线程。</strong><br>    所以可能是在消费过程中有未捕获的异常，导致每分钟执行时都会因为抛出的异常而减少消费者线程池中的线程，直到10个线程都因为抛出异常死掉，就不会有消费者去消费阻塞队列中的Entity了，所以会造成sla阻塞队列中的Entity一直没有被消费，因为此时的SLA消费线程池已经无线程了。<br>    至此，已经分析出问题出现的原因。</p>
<ol start="3">
<li>问题解决<br> 在消费者执行的过程中加入try catch，使得就算消费过程中出现异常也可以在线程中catch，不会导致线程结束。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            // 获取任务，没有任务时会阻塞</span><br><span class="line">                            UrlEntity urlEntity = getUrlEntity();</span><br><span class="line">                            if (urlEntity != null) &#123;</span><br><span class="line">                                CheckRespEntity checkRespEntity = doHealthCheck(urlEntity);</span><br><span class="line">                                // 调用健康检查接口，把调用的结果保留在healthCheckModel对象中</span><br><span class="line">                                checkRespEntity = buildInfluxEntity(checkRespEntity);</span><br><span class="line">                                // 将健康检查结果写入influxDb</span><br><span class="line">                                toInfluxDB(monitorProxy, checkRespEntity);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (Exception ex) &#123;</span><br><span class="line">                            logger.error(&quot;消费线程出错：&quot; + this.getClass().getName(), ex);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>进行单元测试，输入测试用例发现异常出现点，修改优化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line">if (checkRespEntity.getBodyCode() != 0) &#123;</span><br><span class="line">            sendEvent(checkRespEntity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">==》修改后：</span><br><span class="line">if (checkRespEntity.getBodyCode() == null || checkRespEntity.getBodyCode() != 0) &#123;</span><br><span class="line">            sendEvent(checkRespEntity);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-问题总结"><a href="#三-问题总结" class="headerlink" title="三. 问题总结"></a>三. 问题总结</h1><ol>
<li>quartz定时任务默认有10个线程，当线程全部占满时便不会再执行新的定时任务。</li>
<li>执行线程时最好在最外层加入<code>try catch</code>以免线程抛出异常后停止。</li>
<li>修改代码后没有进行充分的单元测试，这个问题可以通过异常测试用例来发现。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础笔记</title>
    <url>/2019/08/22/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="VUE起步"><a href="#VUE起步" class="headerlink" title="VUE起步"></a>VUE起步</h1><p>vue是一个基于MVVM模式的前端框架，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。这个框架的中文文档就很好了，这里只是记录一些本人学习和使用vue时的备忘和笔记。</p>
<blockquote>
<p>官方文档：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></p>
</blockquote>
<span id="more"></span>

<h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><ol>
<li>v-on用来绑定事件 v-on:click=“方法名” (click是一个点击事件)，简写为“@”。</li>
<li>v-for用来遍历数组进行循环。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="line">      &#123;&#123; todo &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>v-if用来进行判断。<br><code>&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</code></li>
<li>v-model用来进行数据的双向绑定</li>
</ol>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>m是data v是样式等，而methods等方法是对数据进行操作，属于vm。在data修改时，页面上的view会自动跟随变化。面向数据（data）编程。<br><img src="/image/mvvm.png" alt="mvvm"></p>
<p>之前的MVP设计模式中，m为数据、v为视图、而p是逻辑，才是设计的重点。数据变化时通过P来对视图进行变化，而视图进行操作时通过p进行数据的更改。<br><img src="/image/mvvm1.png" alt="mvv"></p>
<p>在新的MVVM设计模式中，视图和数据通过vm层相互影响，而vm层则是vue帮我们已经完成的部分，所以可以看作是数据直接驱动视图，视图直接绑定数据的形式。</p>
<h2 id="组件化应用的构建"><a href="#组件化应用的构建" class="headerlink" title="组件化应用的构建"></a>组件化应用的构建</h2><ol>
<li>component{}：用来注册全局组件。在子组件注册时写好其模版和接收的父组件的值。 components{}:在实例中注册局部组件。</li>
<li>v-bind：绑定数据给组件的子组件传递。组件定义时通过props:[]来接收绑定的数据。简写为“：”。</li>
<li>子组件通过props:[]来接收绑定的数据。通过template来编写组件的样式。</li>
<li>v-on监听事件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$emit(“delete”);  //发送一个delete事件</span><br><span class="line">@delete=“handleItemDelete” //监听delete事件，一旦事件触发、执行handleItemDelete方法。</span><br></pre></td></tr></table></figure>
<ol>
<li>父组件向子组件传值可以使用v-bind，在子组件中使用props获取参数。而子组件向父组件传值可以通过父组件监听子组件发出的事件来实现。</li>
</ol>
<h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><p>每一个vue组件都是一个vue实例，在项目的根目录下有一个初始的vue实例，然后通过组件装配来完成项目。<br>在当一个 Vue 实例被创建时，它将 data 对象中的所有的属性加入到 Vue 的响应式系统中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。也就是说，如果在vue实例创建时某属性为在data中，而之后写入的话，则不会有视图响应该属性。</p>
<blockquote>
<p>Vue 实例暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。</p>
</blockquote>
<h2 id="生命周期函数："><a href="#生命周期函数：" class="headerlink" title="生命周期函数："></a>生命周期函数：</h2><p><img src="/image/lifecycle.png" alt="lifecycle"></p>
<p>可以在某个生命周期钩子中写部分操作，例如页面数据的初始网络加载可以放在mounted（）中等等。</p>
<h2 id="vue的模版语法："><a href="#vue的模版语法：" class="headerlink" title="vue的模版语法："></a>vue的模版语法：</h2><p>一般使用插值表达式（两个花括号）。v-text,v-html有同样的功能，v-text和插值表达式相同，而v-html可以对html标签也进行编译。</p>
<h2 id="计算属性和监听器："><a href="#计算属性和监听器：" class="headerlink" title="计算属性和监听器："></a>计算属性和监听器：</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>模版中不应该放入过于复杂的逻辑，所以如果属性需要进行一定的逻辑处理和计算时，可以通过计算属性来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算属性 computed:{}，属性通过计算得出并返回。计算属性是内置缓存的，当他用来计算的值不发生变化时他的值不做重新计算，只有当变化时才重新计算。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听器会对data中的某值进行监听，当其发生变化时会触发监听器中的该方法。但是要注意监听器不能滥用。要区分好什么时候用计算属性、什么时候需要监听。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    // 如果 `question` 发生改变，这个函数就会运行</span><br><span class="line">    question: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">      this.answer = &#x27;Waiting for you to stop typing...&#x27;</span><br><span class="line">      this.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如上，question是data中的一个属性，当question变化时，运行函数并且两个参数分别为之前的值和更改的值。</p>
<h2 id="class和style的绑定"><a href="#class和style的绑定" class="headerlink" title="class和style的绑定"></a>class和style的绑定</h2><h3 id="class绑定"><a href="#class绑定" class="headerlink" title="class绑定"></a>class绑定</h3><p>class是css中的类定义，在绑定class时，可以通过直接对其设置class属性，也可以通过<code>v-bind:class=&quot;&#123; active: isActive &#125;&quot;</code>设置一个对象，在active中写好具体的样式，然后通过isActive的true或false来决定该样式是否在该部分上展示。对应的data中需要有isActive的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，如果样式多，可以通过数组来进行绑定，如：<code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code>，这里绑定了两个数据，在data中有其对应的css样式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeClass: &#x27;active&#x27;,</span><br><span class="line">  errorClass: &#x27;text-danger&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样的写法会使这两个样式固定显示，如果想通过data来对其进行控制展示与否的话，可以在数组中传对象，如：<code>&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;</code>。这样的话，可以在data中控制isActive的true和false来控制显示。</p>
<h3 id="style绑定"><a href="#style绑定" class="headerlink" title="style绑定"></a>style绑定</h3><p>style绑定即是内联元素的绑定，同样通过v-bind进行绑定。看着很像css但是实则是js对象，绑定如下：<code>&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;</code>。</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>v-if绑定的是data中某一值，然后通过该值的true或false来决定该模块是否渲染。v-if还有对应的多重判断，通过<code>v-if</code>、<code>v-else-if</code>以及<code>v-else</code>可以实现多个模块通过条件的判断值显示其中某部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>因为vue中会复用可以复用的元素来实现高效加载，但是如果有不希望去复用的元素，可以通过给他设置一个key值来避免其复用。</p>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>v-show的使用和v-if基本相同，不过v-show的元素始终渲染保留在dom中，v-show控制的只是其css中的dispay的属性。</p>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><blockquote>
<p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
</blockquote>
<h1 id="便签笔记"><a href="#便签笔记" class="headerlink" title="便签笔记"></a>便签笔记</h1><ol>
<li><p>v-on用来绑定事件 v-on:click=“方法名”</p>
</li>
<li><p>v-for用来遍历数组进行循环</p>
</li>
<li><p>v-model用来进行数据的双向绑定</p>
</li>
<li><p>mvvm m是data v是样式等，而methods等方法是对数据进行操作，属于vm。在data修改时，页面上的view会自动跟随变化。面向数据（data）编程。</p>
</li>
<li><p>component{}：用来注册全局组件。在子组件注册时写好其模版和接收的父组件的值。</p>
</li>
<li><p>v-bind：绑定数据给组件的子组件传递。子组件通过props:[]来接收绑定的数据。简写为“：”。</p>
</li>
<li><p>子组件通过props:[]来接收绑定的数据。通过template来编写组件的样式。</p>
</li>
<li><p>v-on监听事件，</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$emit(“delete”);  //发送一个delete事件</span><br><span class="line">@delete=“handleItemDelete” //监听delete事件，一旦事件触发、执行handleItemDelete方法。</span><br></pre></td></tr></table></figure>
<ol>
<li><p>父组件向子组件传值可以使用v-bind，在子组件中使用props获取参数。而子组件向父组件传值可以通过父组件监听子组件发出的事件来实现。</p>
</li>
<li><p>每一个vue组件都是一个vue实例，在项目的根目录下有一个初始的vue实例，然后通过组件装配来完成项目。</p>
</li>
<li><p>插值表达式。v-text。功能一样。v-html也类似，但是会对html标签执行</p>
</li>
<li><p>计算属性 computed:{}，属性通过计算得出并返回。计算属性是内置缓存的，当他用来计算的值不发生变化时他的值不做重新计算，只有当变化时才重新计算</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由传参方法</title>
    <url>/2019/08/02/Vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h1><p>最近在开发中使用vue框架，而通过路由Vue Router可以创建单页应用，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。不同页面的跳转其实是不同组件的跳转（不同.vue的跳转）。<br>需求场景如下：在一个页面中有一个Element的Table，表格中展示不同的应用信息，需要点击应用后可以跳转到该应用详情页面。<br>问题拆分：可以大致分为几个部分，Element的Table的点击事件–点击后执行路由跳转–跳转的同时将点击的appname进行传递–详情页面获取到appname进行查询操作。</p>
<span id="more"></span>

<h1 id="具体解决"><a href="#具体解决" class="headerlink" title="具体解决"></a>具体解决</h1><h2 id="Element中Table的点击事件"><a href="#Element中Table的点击事件" class="headerlink" title="Element中Table的点击事件"></a>Element中Table的点击事件</h2><p>Element的文档中给出如下几种可以实现的方法：<br><img src="/image/element.png" alt="element"></p>
<p>这里我们采用row-click的事件，对应用户点击该行所有单元格都会进行跳转。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-table</span><br><span class="line">        :data=&quot;tableData&quot;</span><br><span class="line">        :header-cell-style=&quot;&#123; textAlign:&#x27;center&#x27; &#125;&quot;</span><br><span class="line">        :cell-style=&quot;&#123; textAlign:&#x27;center&#x27; &#125;&quot;</span><br><span class="line">        @row-click=&quot;handleTable&quot;</span><br><span class="line">      &gt;</span><br><span class="line">&lt;/el-table&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    methods: &#123;handleTable: function(row) &#123;</span><br><span class="line">      this.$router.push(&#123;</span><br><span class="line">          name: &#x27;AppContent&#x27;,</span><br><span class="line">          params: &#123;</span><br><span class="line">            appname: row.appname</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      console.log(row.appname);</span><br><span class="line">      this.$router.replace(&#123; name: &quot;AppContent&quot; &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这里需要注意量点，在设置这个以后，点击table中的编辑和删除后都会执行跳转操作，这明显不是我希望执行的，所以在删除和编辑的button点击事件加一个.stop，代码修改如下：<br><code>&lt;el-button size=&quot;mini&quot; @click.stop=&quot;handleEdit(scope.$index, scope.row)&quot;&gt;编辑&lt;/el-button&gt;</code><br>其次是，返回的row并不是index，而是一个对象，其中包含了一行数据的所有内容，所以在传参数的时候通过row.appname来获取参数。</p>
<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>之前使用的都是导航中的点击跳转，实质上是一个<code>&lt;a&gt;</code>标签，如下：<br><code>&lt;router-link :to=&quot;&#123; name: &#39;Home&#39;&#125;&quot;&gt;主页&lt;/router-link&gt;</code><br>而现在使用的是js中的跳转，通过在methods中实现，代码如下：<br><code>this.$router.replace(&#123; name: &quot;AppContent&quot; &#125;);</code><br>其中AppContent即是路由的name。</p>
<h1 id="Vue路由传参的三种方法"><a href="#Vue路由传参的三种方法" class="headerlink" title="Vue路由传参的三种方法"></a>Vue路由传参的三种方法</h1><h2 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h2><p>传入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getDescribe(id) &#123;</span><br><span class="line">    //   直接调用$router.push 实现携带参数的跳转</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">    path: `/describe/$&#123;id&#125;`,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对应的路由配置如下：<br>很显然，需要在path中添加/:id来对应 $router.push 中path携带的参数。在子组件中可以使用来获取传递的参数值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     path: &#x27;/describe/:id&#x27;,</span><br><span class="line">     name: &#x27;Describe&#x27;,</span><br><span class="line">     component: Describe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在新的页面获取传递的参数方法为：<code>this.$route.params.id</code></p>
<h2 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h2><p>父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。<br>传入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">   name: &#x27;Describe&#x27;,</span><br><span class="line">   params: &#123;</span><br><span class="line">     id: id</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>对应路由配置: 这里可以添加:/id 也可以不添加，不添加数据会在url后面显示，不添加数据就不会显示。</p>
<p>对应的路由配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     path: &#x27;/describe&#x27;,</span><br><span class="line">     name: &#x27;Describe&#x27;,</span><br><span class="line">     component: Describe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子组件中: 这样来获取参数<code>this.$route.params.id</code></p>
<h2 id="方案三："><a href="#方案三：" class="headerlink" title="方案三："></a>方案三：</h2><p>父组件：使用path来匹配路由，然后通过query来传递参数。这种情况下 query传递的参数会显示在url后面?id=？<br>传入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">      path: &#x27;/describe&#x27;,</span><br><span class="line">      query: &#123;</span><br><span class="line">        id: id</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>对应路由配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/describe&#x27;,</span><br><span class="line">  name: &#x27;Describe&#x27;,</span><br><span class="line">  component: Describe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应子组件: 这样来获取参数<code>this.$route.query.id</code></p>
<p>这里我采用了第二种方式。这样就可以解决这个问题。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js中判断字符串中包含另一字符串的五种方法(校验功能)</title>
    <url>/2020/03/03/JS%E6%A0%A1%E9%AA%8C-js%E4%B8%AD%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%8C%85%E5%90%AB%E5%8F%A6%E4%B8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="js中判断字符串中包含另一字符串的五种方法"><a href="#js中判断字符串中包含另一字符串的五种方法" class="headerlink" title="js中判断字符串中包含另一字符串的五种方法"></a>js中判断字符串中包含另一字符串的五种方法</h1><p>JS中判断某个字符串是否包含另一个字符串的五种方法，有string对象的方法，match() 方法，RegExp对象的方法，test() 方法，exec() 方法。<br>通过判断可以实现校验用户输入是否符合标准的功能。</p>
<p>下面将以实际功能举例，例如某输入数据必须是以<code>http://</code>或者是<code>https://</code>开头。</p>
<span id="more"></span>

<h1 id="具体实现方法"><a href="#具体实现方法" class="headerlink" title="具体实现方法"></a>具体实现方法</h1><h2 id="方法一-indexOf"><a href="#方法一-indexOf" class="headerlink" title="方法一 indexOf()"></a>方法一 indexOf()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;http://baidu.com&quot;</span><br><span class="line">console.log(str.indexOf(&quot;http://&quot;) != -1);//true</span><br></pre></td></tr></table></figure>
<p>indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。</p>
<p>Eg:<br><img src="/image/show1.png" alt="sho"></p>
<h2 id="方法二-match"><a href="#方法二-match" class="headerlink" title="方法二 match()"></a>方法二 match()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;http://baidu.com&quot;</span><br><span class="line">var reg = RegExp(/http:\/\//);</span><br><span class="line">if(str.match(reg))&#123;</span><br><span class="line">    //包含</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。<br>Eg:<br><img src="/image/show2.png" alt="sho"></p>
<h2 id="方法三-search"><a href="#方法三-search" class="headerlink" title="方法三 search()"></a>方法三 search()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;http://baidu.com&quot;</span><br><span class="line">console.log(str.search(&quot;http://&quot;) != -1); // true</span><br></pre></td></tr></table></figure>
<p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。</p>
<p>Eg:<br><img src="/image/show3.png" alt="sho"></p>
<h2 id="方法四-test"><a href="#方法四-test" class="headerlink" title="方法四 test()"></a>方法四 test()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;http://baidu.com&quot;</span><br><span class="line">var reg = RegExp(/http:\/\//);</span><br><span class="line">console.log(reg.test(str)); // true</span><br></pre></td></tr></table></figure>
<p>test() 方法用于检索字符串中指定的值。返回 true 或 false。</p>
<p>Eg:<br><img src="/image/show4.png" alt="sho"></p>
<h2 id="方法五-exec"><a href="#方法五-exec" class="headerlink" title="方法五 exec()"></a>方法五 exec()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;http://baidu.com&quot;</span><br><span class="line">var reg = RegExp(/http:\/\//);</span><br><span class="line">if(reg.exec(str))&#123;</span><br><span class="line">    //包含；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<p>Eg:<br><img src="/image/show5.png" alt="sho"></p>
<p>以上五种方法都可以实现判断是否包含<code>http://</code>，而且通过返回值是否为0可以确定匹配到的值是否为字符串刚开始。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中的Stream使用方法</title>
    <url>/2019/10/15/Java8%E4%B8%AD%E7%9A%84Stream%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h1><p>在开发的过程中，很多时候需要对数据进行一系列的操作，而Stream就是将要处理的数据看成是一种流，流在管道中传输，我们可以在管道上的节点添加一些处理逻辑，数据在通过管道中时进行一系列操作，例如筛选、排序、集合等等。<br>而java8中的Stream专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation，就是一系列操作的集合），或者大批量数据操作 (bulk data operation)，Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。<br>同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。</p>
<span id="more"></span>
<h1 id="Stream总览"><a href="#Stream总览" class="headerlink" title="Stream总览"></a>Stream总览</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</p>
<blockquote>
<p>Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。</p>
</blockquote>
<h2 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h2><p>当我们使用一个流的时候，通常包括三个基本步骤：（每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换））</p>
<ol>
<li>获取一个数据源（source）</li>
<li>数据转换</li>
<li>执行操作获取想要的结果<br><img src="/image/%E6%B5%81%E7%AE%A1%E9%81%93%E6%9E%84%E6%88%90-1.png" alt="流管道构成"></li>
</ol>
<h3 id="流的获取"><a href="#流的获取" class="headerlink" title="流的获取"></a>流的获取</h3><p>可以从Collection和数组，从BufferedReader获取，通过静态工厂获取，自己构建或是其他方法。</p>
<h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>流的操作类型分为两种：<br><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。<br><strong>Terminal</strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。<br><strong>short-circuiting</strong>：对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。或对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。<br>（转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。）</p>
<h1 id="Stream使用方法"><a href="#Stream使用方法" class="headerlink" title="Stream使用方法"></a>Stream使用方法</h1><h2 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h2><p>常见的几种构造流的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. Individual values</span><br><span class="line">Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">// 2. Arrays</span><br><span class="line">String [] strArray = new String[] &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line">// 3. Collections</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure>

<h2 id="流的操作-1"><a href="#流的操作-1" class="headerlink" title="流的操作"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。<br><strong>Intermediate：</strong><br>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered<br><strong>Terminal：</strong><br>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator<br><strong>Short-circuiting：</strong><br>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>
<h3 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h3><p>map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。<br>map 1:1映射 Eg：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--平方数--&gt;</span><br><span class="line">List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);</span><br><span class="line">List&lt;Integer&gt; squareNums = nums.stream().</span><br><span class="line">map(n -&gt; n * n).</span><br><span class="line">collect(Collectors.toList());</span><br><span class="line">&lt;!--生成一个整数 list 的平方数 &#123;1, 4, 9, 16&#125;--&gt;</span><br></pre></td></tr></table></figure>

<p>flatMap 1:n映射 Eg：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(1),</span><br><span class="line"> Arrays.asList(2, 3),</span><br><span class="line"> Arrays.asList(4, 5, 6)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure>
<p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--留下偶数--&gt;</span><br><span class="line">Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</span><br><span class="line">&lt;!--经过条件“被 2 整除”的 filter，剩下的数字为 &#123;2, 4, 6&#125;。--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--打印姓名--&gt;</span><br><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure>
<p>forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于<br><code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); </code><br>或<br><code>Integer sum = integers.reduce(0, Integer::sum);</code><br>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 字符串连接，concat = &quot;ABCD&quot;</span><br><span class="line">String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); </span><br><span class="line">// 求最小值，minValue = -3.0</span><br><span class="line">double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line">// 求和，sumValue = 10, 有起始值</span><br><span class="line">int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</span><br><span class="line">// 求和，sumValue = 10, 无起始值</span><br><span class="line">sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();</span><br><span class="line">// 过滤，字符串连接，concat = &quot;ace&quot;</span><br><span class="line">concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;).</span><br><span class="line"> filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0).</span><br><span class="line"> reduce(&quot;&quot;, String::concat);</span><br></pre></td></tr></table></figure>
<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。</p>
<h3 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h3><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; personList2 = persons.stream().</span><br><span class="line">map(Person::getName).limit(10).skip(3).collect(Collectors.toList());</span><br><span class="line"> System.out.println(personList2);</span><br><span class="line">&lt;!--输出：[name4, name5, name6, name7, name8, name9, name10]--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。</p>
<h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>Stream 有三个 match 方法，从语义上说：</p>
<ol>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true<br>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = new ArrayList();</span><br><span class="line">persons.add(new Person(1, &quot;name&quot; + 1, 10));</span><br><span class="line">persons.add(new Person(2, &quot;name&quot; + 2, 21));</span><br><span class="line">persons.add(new Person(3, &quot;name&quot; + 3, 34));</span><br><span class="line">persons.add(new Person(4, &quot;name&quot; + 4, 6));</span><br><span class="line">persons.add(new Person(5, &quot;name&quot; + 5, 55));</span><br><span class="line">boolean isAllAdult = persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; 18);</span><br><span class="line">System.out.println(&quot;All are adult? &quot; + isAllAdult);</span><br><span class="line">boolean isThereAnyChild = persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; 12);</span><br><span class="line">System.out.println(&quot;Any child? &quot; + isThereAnyChild);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">All are adult? false</span><br><span class="line">Any child? true</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之，Stream 的特性可以归纳为：</p>
<ul>
<li>不是数据结构</li>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li>所有 Stream 的操作必须以 lambda 表达式为参数</li>
<li>不支持索引访问</li>
<li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li>
<li>很容易生成数组或者 List</li>
<li>惰性化</li>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
<li>并行能力</li>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的</li>
<li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>
</ul>
<blockquote>
<p>参考文档：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的Pattern和Matcher类的使用以及正则表达式</title>
    <url>/2019/12/26/Java%E4%B8%AD%E7%9A%84Pattern%E5%92%8CMatcher%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p>正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。<br>在线匹配网站：</p>
<blockquote>
<p><a href="https://rubular.com/">https://rubular.com/</a></p>
</blockquote>
<p>可以在线验证正则表达式匹配效果。</p>
<span id="more"></span>

<h2 id="正则表达式字符介绍"><a href="#正则表达式字符介绍" class="headerlink" title="正则表达式字符介绍"></a>正则表达式字符介绍</h2><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p><code>&quot;^&quot; ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。</code> </p>
<p><code>&quot;$&quot;  ：$会匹配行或字符串的结尾</code></p>
<p><code>&quot;\b&quot; :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中&quot;This is Regex&quot;匹配单独的单词 &quot;is&quot; 正则就要写成 &quot;\bis\b&quot;  </code></p>
<p>\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界 </p>
<p><code> &quot;\d&quot;: 匹配数字，</code></p>
<p>例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123  正则:^0\d\d\d-\d\d\d\d\d\d\d$ 这里只是为了介绍”\d”字符，实际上有更好的写法会在     下面介绍。</p>
<p><code> &quot;\w&quot;：匹配字母，数字，下划线.</code></p>
<p>例如我要匹配”a2345BCD__TTz” 正则：”\w+”  这里的”+”字符为一个量词指重复的次数，稍后会详细介绍。</p>
<p><code>&quot;\s&quot;：匹配空格 </code></p>
<p>例如字符 “a b c” 正则：”\w\s\w\s\w”  一个字符后跟一个空格，如有字符间有多个空格直接把”\s” 写成 “\s+” 让空格重复</p>
<p><code>&quot;.&quot;：匹配除了换行符以外的任何字符</code></p>
<p>这个算是”\w”的加强版了”\w”不能匹配 空格 如果把字符串加上空格用”\w”就受限了，看下用 “.”是如何匹配字符”a23 4 5 B C D__TTz”  正则：”.+”</p>
<p><code>&quot;[abc]&quot;: 字符组  匹配包含括号内元素的字符 </code></p>
<p>这个比较简单了只匹配括号内存在的字符，还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了，</p>
<h3 id="反义字符"><a href="#反义字符" class="headerlink" title="反义字符"></a>反义字符</h3><p>写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;\W&quot;   匹配任意不是字母，数字，下划线 的字符</span><br><span class="line"></span><br><span class="line">&quot;\S&quot;   匹配任意不是空白符的字符</span><br><span class="line"></span><br><span class="line">&quot;\D&quot;  匹配任意非数字的字符</span><br><span class="line"></span><br><span class="line">&quot;\B&quot;  匹配不是单词开头或结束的位置</span><br><span class="line"></span><br><span class="line">&quot;[^abc]&quot;  匹配除了abc以外的任意字符</span><br></pre></td></tr></table></figure>

<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>先解释关于量词所涉及到的重要的三个概念</p>
<ul>
<li><p>贪婪(贪心) 如”*”字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的，</p>
</li>
<li><p>懒惰(勉强) 如 “?”  懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。</p>
</li>
<li><p>占有  如”+” 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金</p>
</li>
</ul>
<p><code>&quot;*&quot;(贪婪)   重复零次或更多</code></p>
<p>例如”aaaaaaaa” 匹配字符串中所有的a  正则： “a*”   会出到所有的字符”a”</p>
<p><code>&quot;+&quot;(懒惰)   重复一次或更多次</code></p>
<p>例如”aaaaaaaa” 匹配字符串中所有的a  正则： “a+”  会取到字符中所有的a字符，  “a+”与”a*“不同在于”+”至少是一次而”*” 可以是0次，</p>
<p>稍后会与”?”字符结合来体现这种区别</p>
<p><code>&quot;?&quot;(占有)   重复零次或一次</code></p>
<p>例如”aaaaaaaa” 匹配字符串中的a 正则 ： “a?” 只会匹配一次，也就是结果只是单个字符a</p>
<p><code>&quot;&#123;n&#125;&quot;  重复n次</code></p>
<p>例如从”aaaaaaaa” 匹配字符串的a 并重复3次 正则：  “a{3}”  结果就是取到3个a字符  “aaa”;</p>
<p><code>&quot;&#123;n,m&#125;&quot;  重复n到m次</code></p>
<p>例如正则 “a{3,4}” 将a重复匹配3次或者4次 所以供匹配的字符可以是三个”aaa”也可以是四个”aaaa” 正则都可以匹配到</p>
<p><code>&quot;&#123;n,&#125;&quot;  重复n次或更多次</code></p>
<p>与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则”a{3,}” a至少要重复3次</p>
<p>把量词了解了之后之前匹配电话号码的正则现在就可以改得简单点了<code>^0\d\d\d-\d\d\d\d\d\d\d$</code> 可以改为<code>^0\d+-\d&#123;7&#125;$</code>。</p>
<p>这样写还不够完美如果因为前面的区号没有做限定，以至于可以输入很多们，而通常只能是3位或者4位，</p>
<p>现在再改一下<code> ^0\d&#123;2,3&#125;-\d&#123;7&#125;</code>如此一来区号部分就可以匹配3位或者4位的了</p>
<h3 id="懒惰限定符"><a href="#懒惰限定符" class="headerlink" title="懒惰限定符"></a>懒惰限定符</h3><p><code>&quot;*?&quot;   重复任意次，但尽可能少重复 </code></p>
<p>如 “acbacb”  正则  “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” </p>
<p><code>&quot;+?&quot;  重复1次或更多次，但尽可能少重复</code></p>
<p>与上面一样，只是至少要重复1次</p>
<p><code>&quot;??&quot;  重复0次或1次，但尽可能少重复</code></p>
<p>如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb”</p>
<p><code>&quot;&#123;n,m&#125;?&quot;  重复n到m次，但尽可能少重复</code></p>
<p>如 “aaaaaaaa”  正则 “a{0,m}” 因为最少是0次所以取到结果为空</p>
<p><code>&quot;&#123;n,&#125;?&quot;    重复n次以上，但尽可能少重复</code></p>
<p>如 “aaaaaaa”  正则 “a{1,}” 最少是1次所以取到结果为 “a”</p>
<h2 id="正则进阶"><a href="#正则进阶" class="headerlink" title="正则进阶"></a>正则进阶</h2><h3 id="捕获分组"><a href="#捕获分组" class="headerlink" title="捕获分组"></a>捕获分组</h3><p>先了解在正则中捕获分组的概念，其实就是一个括号内的内容 如 “(\d)\d” 而”(\d)” 这就是一个捕获分组，可以对捕获分组进行 后向引用 (如果后而有相同的内容则可以直接引用前面定义的捕获组，以简化表达式) 如(\d)\d\1 这里的”\1”就是对”(\d)”的后向引用</p>
<p>那捕获分组有什么用呢看个例子就知道了</p>
<p>如  “zery zery” 正则 \b(\w+)\b\s\1\b 所以这里的”\1”所捕获到的字符也是 与(\w+)一样的”zery”，为了让组名更有意义，组名是可以自定义名字的</p>
<p>“\b(?<name>\w+)\b\s\k<name>\b” 用”?<name>“就可以自定义组名了而要后向引用组时要记得写成 “\k<name>“;自定义组名后,捕获组中匹配到的值就会保存在定义的组名里</p>
<p>下面列出捕获分组常有的用法:</p>
<p><code>&quot;(exp)&quot; </code>   匹配exp,并捕获文本到自动命名的组里</p>
<p><code>&quot;(?&lt;name&gt;exp)&quot;</code>   匹配exp,并捕获文本到名称为name的组里</p>
<p><code>&quot;(?:exp)&quot;</code>  匹配exp,不捕获匹配的文本，也不给此分组分配组号</p>
<p>以下为零宽断言</p>
<p><code>&quot;(?=exp)&quot;</code>  匹配exp前面的位置</p>
<p>如 “How are you doing” 正则”(?<txt>.+(?=ing))” 这里取ing前所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为”How are you do”;</p>
<p><code>&quot;(?&lt;=exp)&quot;</code>  匹配exp后面的位置</p>
<p>如 “How are you doing” 正则”(?<txt>(?&lt;=How).+)” 这里取”How”之后所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为” are you doing”;</p>
<p><code>&quot;(?!exp)&quot;</code>  匹配后面跟的不是exp的位置</p>
<p>如 “123abc” 正则 “\d{3}(?!\d)”匹配3位数字后非数字的结果</p>
<p><code>&quot;(?&lt;!exp)&quot;</code>  匹配前面不是exp的位置</p>
<p>如 “abc123 “ 正则 “(?&lt;![0-9])123” 匹配”123”前面是非数字的结果也可写成”(?!&lt;\d)123”</p>
<h1 id="Java中Pattern和Matcher类使用"><a href="#Java中Pattern和Matcher类使用" class="headerlink" title="Java中Pattern和Matcher类使用"></a>Java中Pattern和Matcher类使用</h1><h2 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h2><p>Pattern类的作用在于编译正则表达式后创建一个匹配模式.</p>
<p><strong>常用方法介绍：</strong></p>
<p><code>Pattern complie(String regex)</code><br>由于Pattern的构造函数是私有的,不可以直接创建,所以通过静态方法compile(String regex)方法来创建,将给定的正则表达式编译并赋予给Pattern类</p>
<p><code>String pattern() </code><br>返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String regex = &quot;\\?|\\*&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">String patternStr = pattern.pattern();//返回\?\*</span><br></pre></td></tr></table></figure>

<p><code>Pattern.matcher(CharSequence input)</code><br>对指定输入的字符串创建一个Matcher对象，input就是要甄别是否匹配正则表达式的输入串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(&quot;\\?&#123;2&#125;&quot;);</span><br><span class="line">Matcher matcher = pattern.matcher(&quot;??&quot;);</span><br><span class="line">boolean matches = matcher.matches();// true</span><br></pre></td></tr></table></figure>

<p><code>String[] split(CharSequence input)</code><br>String[] split(CharSequence input, int limit)</p>
<p><code>String[] split(CharSequence input, int limit)</code><br>功能和String[] split(CharSequence input)相同,增加参数limit目的在于要指定分割的段数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String regex = &quot;\\?|\\*&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">String[] splitStrs = pattern.split(&quot;123?123*456*456&quot;);//123 123 456 456</span><br><span class="line">String[] splitStrs2 = pattern.split(&quot;123?123*456*456&quot;, 2);// 123 123*456*456</span><br></pre></td></tr></table></figure>

<h2 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h2><p>Matcher类使用Pattern实例提供的模式信息对正则表达式进行匹配</p>
<p><strong>常用方法及介绍：</strong><br><code>boolean matches()</code><br>最常用方法:尝试对整个目标字符展开匹配检测,也就是只有整个目标字符串完全匹配时才返回真值.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(&quot;\\?&#123;2&#125;&quot;);</span><br><span class="line">Matcher matcher = pattern.matcher(&quot;??&quot;);</span><br><span class="line">boolean matches = matcher.matches();//true</span><br><span class="line">System.out.println(matches);</span><br><span class="line">matcher=pattern.matcher(&quot;?&quot;);</span><br><span class="line">matches = matcher.matches();//false</span><br><span class="line">System.out.println(matches);</span><br></pre></td></tr></table></figure>

<p><code>boolean lookingAt()</code><br>对前面的字符串进行匹配,只有匹配到的字符串在最前面才会返回true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(&quot;\\d+&quot;);</span><br><span class="line">Matcher m = p.matcher(&quot;22bb23&quot;);</span><br><span class="line">boolean match = m.lookingAt();//true</span><br><span class="line">System.out.println(match);</span><br><span class="line">m = p.matcher(&quot;bb2233&quot;);</span><br><span class="line">match= m.lookingAt();</span><br><span class="line">System.out.println(match);//false</span><br></pre></td></tr></table></figure>

<p><code>boolean find()</code><br>对字符串进行匹配,匹配到的字符串可以在任何位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(&quot;\\d+&quot;);</span><br><span class="line">Matcher m = p.matcher(&quot;22bb23&quot;);</span><br><span class="line">m.find();// 返回true</span><br><span class="line">Matcher m2 = p.matcher(&quot;aa2223&quot;);</span><br><span class="line">m2.find();// 返回true</span><br><span class="line">Matcher m3 = p.matcher(&quot;aa2223bb&quot;);</span><br><span class="line">m3.find();// 返回true</span><br><span class="line">Matcher m4 = p.matcher(&quot;aabb&quot;);</span><br><span class="line">m4.find();// 返回false</span><br></pre></td></tr></table></figure>

<p><code>int start()</code><br>返回当前匹配到的字符串在原目标字符串中的位置</p>
<p><code>int end()</code><br>返回当前匹配的字符串的最后一个字符在原目标字符串中的索引位置</p>
<p><code>String group()</code><br>返回匹配到的子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(&quot;\\d+&quot;);</span><br><span class="line">Matcher m = p.matcher(&quot;aa22bb23&quot;);</span><br><span class="line">m.find();</span><br><span class="line">int start = m.start();//2</span><br><span class="line">String group = m.group();//22</span><br><span class="line">int end = m.end();//4</span><br><span class="line">System.out.println(start);</span><br><span class="line">System.out.println(group);</span><br><span class="line">System.out.println(end);</span><br></pre></td></tr></table></figure>

<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>例如要处理tag，tag中是xxxx=xxxx格式。要获取tag中等号两边的值，作为key和value进行存储。处理如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Pattern filter = Pattern.compile(&quot;(?&lt;key&gt;[\\w\\-\\s]+)\\s*=\\s*(?&lt;value&gt;[\\w\\-\\s]+)&quot;);</span><br><span class="line"></span><br><span class="line">private void test ()&#123;</span><br><span class="line">    Matcher matcherEqual = filter.matcher(&quot;cat=animal&quot;);</span><br><span class="line">    if(matcherEqual.matches())&#123;</span><br><span class="line">    //如果输入匹配，则进入按组取出value值</span><br><span class="line">    String key = matcherEqual.group(&quot;key&quot;);</span><br><span class="line">    String value = matcherEqual.group(&quot;value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，使用方法：<br>skip 1：<br>通过Pattern来创建一个正则表达式匹配规则。<br>skip 2：<br>通过创建的匹配规则对输入值进行匹配验证，并将一系列结果存放至Matcher类中。<br>skip 3：<br>通过Matcher的matches()方法，返回是否匹配，并可以按组来取出匹配值。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz框架实现定时任务</title>
    <url>/2019/07/25/Quartz%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>  在开发过程中，需要实现定时来执行某些方法任务，这时可以使用Quartz框架来实现这个功能。</p>
<h1 id="Quartz简单使用"><a href="#Quartz简单使用" class="headerlink" title="Quartz简单使用"></a>Quartz简单使用</h1><p>  Quartz中主要包含几个核心概念，如下：</p>
<ol>
<li>Job 表示一个工作，要执行的具体内容。此接口中只有一个方法，如下：</li>
</ol>
<p><code>void execute(JobExecutionContext context) </code></p>
<ol start="2">
<li>JobDetail 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。 </li>
<li>Trigger 代表一个调度参数的配置，什么时候去调。 </li>
<li>Scheduler 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。 </li>
</ol>
<span id="more"></span>

<h2 id="配置Scheduler"><a href="#配置Scheduler" class="headerlink" title="配置Scheduler"></a>配置Scheduler</h2><p>  上文说Scheduler是一个调度容器，任意一个JobDetail和任意一个Trigger结合为一对即可进行注册，而Scheduler需要实例化，只有在实例化以后，才能执行他的启动(start)、暂停(stand-by)、停止(shutdown)方法。<br>  注意：scheduler被停止后，除非重新实例化，否则不能重新启动；只有当scheduler启动后，即使处于暂停状态也不行，trigger才会被触发（job才会被执行）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SchedulerFactory schedFact = new org.quartz.impl.StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line">  Scheduler sched = schedFact.getScheduler();</span><br><span class="line"></span><br><span class="line">  sched.start();</span><br><span class="line"></span><br><span class="line">  // define the job and tie it to our HelloJob class</span><br><span class="line">  JobDetail job = newJob(HelloJob.class)</span><br><span class="line">      .withIdentity(&quot;myJob&quot;, &quot;group1&quot;)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  // Trigger the job to run now, and then every 40 seconds</span><br><span class="line">  Trigger trigger = newTrigger()</span><br><span class="line">      .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;)</span><br><span class="line">      .startNow()</span><br><span class="line">      .withSchedule(simpleSchedule()</span><br><span class="line">          .withIntervalInSeconds(40) //每40s执行一次</span><br><span class="line">          .repeatForever())</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  // Tell quartz to schedule the job using our trigger</span><br><span class="line">  sched.scheduleJob(job, trigger); </span><br></pre></td></tr></table></figure>
<h2 id="实现jobDetail"><a href="#实现jobDetail" class="headerlink" title="实现jobDetail"></a>实现jobDetail</h2><p>  具体的工作类需要实现接口Job，接口需要实现一个execute方法，而具体的job要执行的任务，就写在execute方法中。如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloJob implements Job &#123;</span><br><span class="line"></span><br><span class="line">    public HelloJob() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(JobExecutionContext context)</span><br><span class="line">      throws JobExecutionException</span><br><span class="line">    &#123;</span><br><span class="line">      System.err.println(&quot;Hello!  HelloJob is executing.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Quartz和Spring-boot结合"><a href="#Quartz和Spring-boot结合" class="headerlink" title="Quartz和Spring boot结合"></a>Quartz和Spring boot结合</h1><p>  创建一个监听类来实现配置Scheduler，使Spring boot在启动时自动加载该类，开始定时任务。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TimedRegister implements ApplicationListener&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    FindMessage findMessage;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Grab the Scheduler instance from the Factory</span><br><span class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">            // and start it off</span><br><span class="line">            scheduler.start();</span><br><span class="line"></span><br><span class="line">            // define the job and tie it to our HelloJob class</span><br><span class="line">            JobDetail mysqlDoJob = JobBuilder.newJob(MysqlTimedSendJob.class)</span><br><span class="line">                    .withIdentity(&quot;job1&quot;, &quot;jobGroup1&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            mysqlDoJob.getJobDataMap().put(&quot;findMessage&quot;, findMessage);</span><br><span class="line"></span><br><span class="line">            Trigger mysqlTrigger = newTrigger()</span><br><span class="line">                    .withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)</span><br><span class="line">                    .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0 0 10 * * ?&quot;))</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            scheduler.scheduleJob(mysqlDoJob, mysqlTrigger);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;TimedRegister daily job error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上需要注意几点：</strong></p>
<ol>
<li><p>ApplicationListener接口中需要传入监听参数（ApplicationReadyEvent），因为如果不传入参数的话，会对每个event都进行监听，则会发生同时执行好几个定时任务这样的惨状。这个问题不只存在与定时任务的监听。</p>
</li>
<li><p>先看一段解释：<br>　　我们传给scheduler一个JobDetail实例，因为我们在创建JobDetail时，将要执行的job的类名传给了JobDetail，所以scheduler就知道了要执行何种类型的job；每次当scheduler执行job时，在调用其execute(…)方法之前会创建该类的一个新的实例；执行完毕，对该实例的引用就被丢弃了，实例会被垃圾回收；这种执行策略带来的一个后果是，job必须有一个无参的构造函数（当使用默认的JobFactory时）；另一个后果是，在job类中，不应该定义有状态的数据属性，因为在job的多次执行中，这些属性的值不会保留。那么如何给job实例增加属性或配置呢？如何在job的多次执行中，跟踪job的状态呢？答案就是:JobDataMap，JobDetail对象的一部分。<br>　　因为job的具体类不是Spring创建的，而是quartz创建的，所以不能通过注入的方式来调用findmessage，只能通过将这个findmessage创建对象后通过参数注入的方式由JobDataMap来传入Job具体的实现中。所以我们在jobdetail中添加参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　mysqlDoJob.getJobDataMap().put(&quot;findMessage&quot;, findMessage);</span><br></pre></td></tr></table></figure>
<p>然后在job的具体方法中，通过getdetail然后getjobdatamap的方式来获取具体的findMessage方法，从而实现定时执行一个方法的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        FindMessage findMessage = (FindMessage) jobExecutionContext.getJobDetail()</span><br><span class="line">                .getJobDataMap().get(&quot;findMessage&quot;);</span><br><span class="line">        logger.info(&quot;get findMessage instance success&quot;);</span><br><span class="line"></span><br><span class="line">        findMessage.findDayMessage();</span><br><span class="line">        logger.info(&quot;send ding from mysql is success&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Quartz中的JobDataMap使用指南"><a href="#Quartz中的JobDataMap使用指南" class="headerlink" title="Quartz中的JobDataMap使用指南"></a>Quartz中的JobDataMap使用指南</h1><p>  JobDataMap中可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用其中的数据；JobDataMap是Java Map接口的一个实现，额外增加了一些便于存取基本类型的数据的方法。<br>  将job加入到scheduler之前，在构建JobDetail时，可以将数据放入JobDataMap。<br>  所以可以在添加JobDetail时添加jobDataMap，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　 　// define the job and tie it to our DumbJob class</span><br><span class="line">JobDetail job = newJob(DumbJob.class)</span><br><span class="line">    .withIdentity(&quot;myJob&quot;, &quot;group1&quot;) // name &quot;myJob&quot;, group &quot;group1&quot;</span><br><span class="line">    .usingJobData(&quot;jobSays&quot;, &quot;Hello World!&quot;)</span><br><span class="line">    .usingJobData(&quot;myFloatValue&quot;, 3.141f)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>  然后在job的具体类中将其取出，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DumbJob implements Job &#123;</span><br><span class="line"></span><br><span class="line">  public DumbJob() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void execute(JobExecutionContext context)</span><br><span class="line">    throws JobExecutionException</span><br><span class="line">  &#123;</span><br><span class="line">    JobKey key = context.getJobDetail().getKey();</span><br><span class="line"></span><br><span class="line">    JobDataMap dataMap = context.getJobDetail().getJobDataMap();</span><br><span class="line"></span><br><span class="line">    String jobSays = dataMap.getString(&quot;jobSays&quot;);</span><br><span class="line">    float myFloatValue = dataMap.getFloat(&quot;myFloatValue&quot;);</span><br><span class="line"></span><br><span class="line">    System.err.println(&quot;Instance &quot; + key + &quot; of DumbJob says: &quot; + jobSays + &quot;, and val is: &quot; + myFloatValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中使用JPA访问数据库</title>
    <url>/2019/07/26/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8JPA%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="SpringBoot中使用JPA访问数据库"><a href="#SpringBoot中使用JPA访问数据库" class="headerlink" title="SpringBoot中使用JPA访问数据库"></a>SpringBoot中使用JPA访问数据库</h1><h2 id="JPA概念"><a href="#JPA概念" class="headerlink" title="JPA概念"></a>JPA概念</h2><p>  jpa是Java Persistence API的简称，即为java持久层api，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中，简单来说就是将数据库中的关系表映射为java中的一个类，然后在java运行时，将这个类的实体对象持久化到数据库中。（这和使用android中的litepal很像）<br>  优点：持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。<br>  <span id="more"></span></p>
<h2 id="SpringBoot使用JPA"><a href="#SpringBoot使用JPA" class="headerlink" title="SpringBoot使用JPA"></a>SpringBoot使用JPA</h2><h3 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h3><p>  Spring boot有着jpa的起步依赖，将以下依赖添加到pom中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>  添加了依赖之后，还需要在<strong>application.properties</strong>配置文件中添加依赖数据库的具体信息，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://url/databaseName</span><br><span class="line">spring.datasource.username=xxxx</span><br><span class="line">spring.datasource.password=xxxx</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<h3 id="定义实体类"><a href="#定义实体类" class="headerlink" title="定义实体类"></a>定义实体类</h3><h4 id="单主键"><a href="#单主键" class="headerlink" title="单主键"></a>单主键</h4><p>  将需要访问的数据库中的表定义为一个实体类，在类前加上注释@Entity(name = “xxx”)其中xxx为对应的数据库中的表名称，将主键注释为@Id，将列的字段注视为@Column，并为其分别设置get和set方法。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @Entity(name = &quot;xxxx&quot;)</span><br><span class="line">public class BVCodeEntity &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private String id;</span><br><span class="line">    @Column</span><br><span class="line">    private String code;</span><br><span class="line">    </span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="复合主键"><a href="#复合主键" class="headerlink" title="复合主键"></a>复合主键</h4><p>  在数据库中，有可能是复合主键，这时如果直接通过给多个字段值都注释为@Id是不对的，需要给他创建一个复合主键类并实现Serializable，从而能使其序列化。同时在他对应的类中，还需要给他写构造方法。例如一个表中，主键为code和systemCode，复合主键类代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 复合主键类，存放联合主键属性，实现序列化接口</span><br><span class="line"> * */</span><br><span class="line">public class CompositeKeyforResult implements Serializable &#123;</span><br><span class="line">    private  String code;</span><br><span class="line">    private String systemCode;</span><br><span class="line">    public String getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSystemCode() &#123;</span><br><span class="line">        return systemCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSystemCode(String systemCode) &#123;</span><br><span class="line">        this.systemCode = systemCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>  以上就是创建了一个复合主键类，他的表对应的实体类在注释中加入@IdClass把刚才定义好的复合主键类导入，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Entity(name = &quot;xxx&quot;)</span><br><span class="line">@IdClass(CompositeKeyforResult.class)</span><br><span class="line">public class BVResultEntity  &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private String systemCode;</span><br><span class="line">    @Id</span><br><span class="line">    @Column</span><br><span class="line">    private String code;</span><br><span class="line">   </span><br><span class="line">    @Column</span><br><span class="line">    private String staName;</span><br><span class="line">    @Column</span><br><span class="line">    private Date createTime;</span><br><span class="line">    </span><br><span class="line">     public BVResultEntity()&#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BVResultEntity(String systemCode, String deviceId, String code, Date bizTime) &#123;</span><br><span class="line">        this.systemCode = systemCode;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getSystemCode() &#123;</span><br><span class="line">        return systemCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSystemCode(String systemCode) &#123;</span><br><span class="line">        this.systemCode = systemCode;</span><br><span class="line">    &#125;</span><br><span class="line">     public String getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getStaName() &#123;</span><br><span class="line">        return staName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStaName(String staName) &#123;</span><br><span class="line">        this.staName = staName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getCreateTime() &#123;</span><br><span class="line">        return createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCreateTime(Date createTime) &#123;</span><br><span class="line">        this.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h3><p>  在创建Repository中，继承自JpaRepository并把前面创建的实体Entity传入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BVRepository extends JpaRepository&lt;BVResultEntity,Integer&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Repository查询数据"><a href="#使用Repository查询数据" class="headerlink" title="使用Repository查询数据"></a>使用Repository查询数据</h3><p>  在需要获取数据库数据时，要先注入要查询表的对应的repository，然后即可以通过repository来获取一些数据库的信息。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">BVRepository bvRepository;</span><br><span class="line"></span><br><span class="line">//读取列表</span><br><span class="line">return studentRepository.findAll();</span><br><span class="line"></span><br><span class="line">//排序,创建Sort对象的第二个参数，是java对象的属性，而不是mysql数据表的列名</span><br><span class="line">Sort sort = new Sort(Sort.Direction.DESC,&quot;code&quot;);</span><br><span class="line">return bvtRepository.findAll(sort);</span><br><span class="line"></span><br><span class="line">//分页(+排序)</span><br><span class="line">Sort sort = new Sort(Sort.Direction.ASC, &quot;code&quot;);</span><br><span class="line">Pageable pageable = PageRequest.of(pageNumber -1, 5, sort);</span><br><span class="line">return bvRepository.findAll(pageable).getContent();</span><br></pre></td></tr></table></figure>


<h4 id="添加自定义方法查询"><a href="#添加自定义方法查询" class="headerlink" title="添加自定义方法查询"></a>添加自定义方法查询</h4><p>  我们还可以在repository中添加一些自定义的语句，hibernate会自动为其装配sql语句。如添加一个findByXXX()，但是这里有个需要注意，其中的ByXXX中XXX需要和java中对象的属性保持一致，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BVCodeRepository extends JpaRepository&lt;BVCodeEntity,Integer&gt; &#123;</span><br><span class="line">    public BVCodeEntity findByCode(String code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="添加自定义sql语句查询"><a href="#添加自定义sql语句查询" class="headerlink" title="添加自定义sql语句查询"></a>添加自定义sql语句查询</h4><p>  有一些特殊的情况，只是通过自定义方法是不够精细的查询数据库的，这时候还可以使用直接的SQL语句来进行查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BVResultRepository extends JpaRepository&lt;BVResultEntity,Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Query(value =&quot;select * from XXX where create_time &gt;=(NOW() - interval 24 hour)&quot;, nativeQuery = true)</span><br><span class="line">    public List&lt;BVResultEntity&gt; findDailyResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>查询24小时内创建的数据，其中nativeQuery设为true表明使用原始的Sql语句。输出为一个Entity的list。
</code></pre>
<blockquote>
<p>Spring data jpa官方文档：<a href="https://docs.spring.io/spring-data/jpa/docs/2.1.0.M2/reference/html/">https://docs.spring.io/spring-data/jpa/docs/2.1.0.M2/reference/html/</a><br>学习自Kite__博客：<a href="https://blog.csdn.net/daguanjia11/article/details/80026908">https://blog.csdn.net/daguanjia11/article/details/80026908</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue多环境启动</title>
    <url>/2019/09/06/Vue%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="Vue多环境启动的解决方法"><a href="#Vue多环境启动的解决方法" class="headerlink" title="Vue多环境启动的解决方法"></a>Vue多环境启动的解决方法</h1><h2 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h2><p>在vue项目开发中，因为本地、测试、生产三个环节中常常对应不同的接口，所以需要解决如何在运行三种不同的环境时就获取到三种不同的接口的问题。</p>
<h2 id="Vue-Cli-3版本"><a href="#Vue-Cli-3版本" class="headerlink" title="Vue Cli 3版本"></a>Vue Cli 3版本</h2><p>Vue Cli文档：</p>
<blockquote>
<p><a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-serve">https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-serve</a><br>在Vue Cli 2版本或更早的版本，项目目录中包括build和config文件夹。而这次开发使用的是3.0以上的版本，不生成这两个文件夹，所以这里只介绍3.0以上的版本的解决方法。项目目录如下：</p>
</blockquote>
<span id="more"></span>
<p><img src="/image/%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95.png" alt="项目目录"></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>通过为<code>.env</code>文件增加后缀来设置某个模式下特有的环境变量。<br>通过传递 –mode 选项参数为命令行覆写默认的模式。</p>
<h2 id="新建-env文件"><a href="#新建-env文件" class="headerlink" title="新建.env文件"></a>新建.env文件</h2><p>在项目的根目录新建2个文件，分别对应开发（dev），生产（prod）<br>文件命名： .env.dev , .env.prod。如下：<br><img src="/image/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6.png" alt="新建文件"></p>
<p>在每个文件中写具体的参数。接下来是不同文件里面的代码情况。</p>
<blockquote>
<p>注意：需要以’VUE_APP_’开头来写。</p>
</blockquote>
<p>.env.dev</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NODE_ENV = &#x27;development&#x27;</span><br><span class="line">VUE_APP_CURRENTMODE = &#x27;dev&#x27;</span><br><span class="line">VUE_APP_BASEURL = &#x27;本地开发的基础api地址&#x27;</span><br></pre></td></tr></table></figure>

<p>.env.test （本次没有设置test文件）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NODE_ENV = &#x27;production&#x27;</span><br><span class="line">VUE_APP_CURRENTMODE = &#x27;test&#x27;</span><br><span class="line">VUE_APP_BASEURL = &#x27;测试环境api地址&#x27;</span><br></pre></td></tr></table></figure>

<p>.env.prod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NODE_ENV = &#x27;production&#x27;</span><br><span class="line">VUE_APP_CURRENTMODE = &#x27;prod&#x27;</span><br><span class="line">VUE_APP_BASEURL = &#x27;正式环境api地址&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="修改package-json脚本"><a href="#修改package-json脚本" class="headerlink" title="修改package.json脚本"></a>修改package.json脚本</h2><p>在根目录下的package.json文件进行以下修改。<br><img src="/image/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6.png" alt="修改文件"></p>
<p>其中前面的key部分，就是命令执行时 <code>npm run xxxxx</code>的部分，而后面的则是vue cli执行的内容，下面是是文档中的部分内容。<br><img src="/image/%E6%96%87%E6%A1%A31.png" alt="文档1"><img src="/image/%E6%96%87%E6%A1%A32.png" alt="文档2"></p>
<p>其中mode后接的是要部署的环境，具体的名称就是第一步创建的.env.xxx中的xxx名称。如这里就是prod和dev。同时这里在两种不同的环境分别设置了serve命令和build命令。</p>
<p>（serve和build有一定的区别，serve是直接在本地执行。而build是进行打包，创建出一个dist文件夹，其中的index文件是入口。）</p>
<h2 id="使用api"><a href="#使用api" class="headerlink" title="使用api"></a>使用api</h2><p>在.env.prod和.env.dev中定义了VUE_APP_XXXXX的变量，在调用时，直接使用<code>process.env.VUE_APP_BASEURL</code>即可。在这里我把他绑定在原型链上以方便全局使用。如下：<br><img src="/image/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="使用方法"></p>
<p>这样使用时可以通过this.BaseUrl来调用地址，而这个值就是设置的多环境变量赋值给他的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要设置多环境分为以下几步：</p>
<ol>
<li>创建对应环境的.env.xxxx</li>
<li>在package.json文件中设置对应的命令（mode）</li>
<li>通过<code>process.env.VUE_APP_BASEURL</code>来调用具体的设置值。（启动命令不同，环境不同，对应的baseUrl也不同，实现目的功能。）</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础数据类型与流程控制</title>
    <url>/2021/10/20/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数据与变量"><a href="#数据与变量" class="headerlink" title="数据与变量"></a>数据与变量</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>go是静态类型数据结构，但是也可以不声明类型通过编译器来判断。但是最好显示的声明类型。</p>
<span id="more"></span>
<p>1    布尔型<br>布尔型的值只可以是常量 true 或者 false。一个简单的例子：<code>var b bool = true</code>。<br>2    数字类型<br>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。<br><code>var i int = 3</code><br><code>var f float32 = 0.111</code><br>3    字符串类型:<br>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。<br><code>var s string = &quot;too&quot;</code><br>4 数组类型：<br>数组可以存储不同类型的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> beatles [<span class="number">4</span>]<span class="keyword">string</span></span><br><span class="line">beatles[<span class="number">0</span>] = <span class="string">&quot;John&quot;</span></span><br><span class="line">beatles[<span class="number">1</span>] = <span class="string">&quot;Pual&quot;</span></span><br><span class="line">beatles[<span class="number">2</span>] = <span class="string">&quot;John2&quot;</span></span><br><span class="line">beatles[<span class="number">3</span>] = <span class="string">&quot;John3&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="变量声明方式"><a href="#变量声明方式" class="headerlink" title="变量声明方式"></a>变量声明方式</h2><p>注：不能在函数外使用简短变量声明<br>变量声明方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">string</span></span><br><span class="line">t = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短声明变量</span></span><br><span class="line">u := <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>将变量传递给函数时候，会分配新的内存并将变量的值复制到其中</strong>。这样就会有两个变量实例，处于不同的内存单元中。这样会造成占用更多的内存，同时因为存在多个副本，容易导致bug，所以我们可以通过指针传递方式来传递变量。<br>使用&amp;获取变量地址，使用*获取指针的变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMemoryAdderss</span><span class="params">(x *<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(*x) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i :=<span class="number">1</span></span><br><span class="line">    fmt.Println(i) <span class="comment">// 1</span></span><br><span class="line">    showMemoryAdderss(&amp;i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串拼接可以使用+来直接拼接，但是需要都是字符串类型。如整数型和字符串拼接会报错。<br>如果需要不同类型拼接，需要用函数将其转为字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">1</span> <span class="comment">// int</span></span><br><span class="line">	intToString := strconv.Itoa(i)</span><br><span class="line">	<span class="keyword">var</span> s = <span class="string">&quot; egg&quot;</span> <span class="comment">// string</span></span><br><span class="line">	<span class="keyword">var</span> breakfast = intToString + s</span><br><span class="line">	fmt.Println(breakfast)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>同java一样，如果多次操作string拼接，性能不会很好，这时可以使用缓冲区。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">		buffer.WriteString(<span class="string">&quot;z&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(buffer.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些常用的strings包方法"><a href="#一些常用的strings包方法" class="headerlink" title="一些常用的strings包方法"></a>一些常用的strings包方法</h3><ol>
<li>变全小写</li>
<li>寻找string中子串</li>
<li>去除字符串前后空格<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strings.ToLower(<span class="string">&quot;AKG&quot;</span>))</span><br><span class="line">	fmt.Println(strings.Index(<span class="string">&quot;surface&quot;</span>, <span class="string">&quot;face&quot;</span>))</span><br><span class="line">	fmt.Println(strings.Index(<span class="string">&quot;moon&quot;</span>, <span class="string">&quot;aer&quot;</span>))</span><br><span class="line">	fmt.Println(strings.TrimSpace(<span class="string">&quot;   I don&#x27;t need all this space     &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h1><p>函数本身也是一个类型，可以在一个函数传递参数中 传递另外一个函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n, s := getPrize(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(n) <span class="comment">// 3</span></span><br><span class="line">	fmt.Println(s) <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPrize</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">	<span class="keyword">return</span> i + j, s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h2><p>go和java一个区别就是，在go的if或者for语句中，条件都不用加小括号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> b &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;b is true&quot;</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;b is false&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i :=<span class="number">2</span></span><br><span class="line">	<span class="keyword">switch</span> i &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;i is 1&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;i is 2&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;switch is done&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>在第三种方式中，第一个值为index，循环中的次数。第二个值为便利数组中的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="number">2</span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;i is &quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;j is &quot;</span>, j)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	numbers := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> index, num := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot; the index of loop is &quot;</span>,index)</span><br><span class="line">		fmt.Println(<span class="string">&quot; this num is &quot;</span>,num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后结果：<br><img src="/image/16352288253537.jpg"></p>
<h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>defer在该函数执行结束返回前执行。通常用于执行清理操作或 确保操作。<br>如果一个函数中有多个defer，将按入栈方式 先进后出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;func finish&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 1&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 2&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="/image/16352290763431.jpg"></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器文件传输rz/sz的相关配置</title>
    <url>/2021/03/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93rz-sz%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在沙盒环境部署服务时，需要在服务器上进行替换jar包并重新启动的操作。而服务器是通过跳板机登录的，不太方便使用scp命令。所以这里使用rz（文件上传），sz filename （文件下载）命令来执行相关操作。</p>
<span id="more"></span>

<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>工具：iterm2，brew</p>
<h1 id="配置操作"><a href="#配置操作" class="headerlink" title="配置操作"></a>配置操作</h1><h2 id="安装lrzsz（需先安装brew）"><a href="#安装lrzsz（需先安装brew）" class="headerlink" title="安装lrzsz（需先安装brew）"></a>安装lrzsz（需先安装brew）</h2><p>brew install lrzsz</p>
<p>注意：这里需要注意你的brew将包安装的地址，是/usr/local/bin还是/opt/homebrew/bin/，在bin目录下有sz、rz等文件。</p>
<h2 id="下载-iterm2-send-zmodem-sh-和-iterm2-recv-zmodem-sh"><a href="#下载-iterm2-send-zmodem-sh-和-iterm2-recv-zmodem-sh" class="headerlink" title="下载 iterm2-send-zmodem.sh 和 iterm2-recv-zmodem.sh"></a>下载 iterm2-send-zmodem.sh 和 iterm2-recv-zmodem.sh</h2><p>下载 iterm2-send-zmodem.sh 和 iterm2-recv-zmodem.sh保存到Mac的/usr/local/bin或是/opt/homebrew/bin/路径下。根据lrzsz路径判断。</p>
<p>下载路径1 Github：<a href="https://github.com/mmastrac/iterm2-zmodem">https://github.com/mmastrac/iterm2-zmodem</a><br>下载路径2 网盘： <a href="https://pan.baidu.com/s/14047z_CW5g6PPNP0xyyOkg%EF%BC%88wt30%EF%BC%89">https://pan.baidu.com/s/14047z_CW5g6PPNP0xyyOkg（wt30）</a><br>下载路径3 直接创建两个文件并编辑。</p>
<p>iterm2-recv-zmodem.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: Matt Mastracci (matthew@mastracci.com)</span></span><br><span class="line"><span class="comment"># AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script</span></span><br><span class="line"><span class="comment"># licensed under cc-wiki with attribution required </span></span><br><span class="line"><span class="comment"># Remainder of script public domain</span></span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to version&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$NAME</span> = <span class="string">&quot;iTerm&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$FILE</span> = <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Cancelled.</span><br><span class="line">    <span class="comment"># Send ZModem cancel</span></span><br><span class="line">    <span class="built_in">echo</span> -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">    sleep 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Cancelled transfer</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span></span><br><span class="line">    /opt/homebrew/bin/rz -E -e -b</span><br><span class="line">    sleep 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Sent \-\&gt; $FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>


<p>iterm2-send-zmodem.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: Matt Mastracci (matthew@mastracci.com)</span></span><br><span class="line"><span class="comment"># AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script</span></span><br><span class="line"><span class="comment"># licensed under cc-wiki with attribution required </span></span><br><span class="line"><span class="comment"># Remainder of script public domain</span></span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to version&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$NAME</span> = <span class="string">&quot;iTerm&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$FILE</span> = <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Cancelled.</span><br><span class="line">    <span class="comment"># Send ZModem cancel</span></span><br><span class="line">    <span class="built_in">echo</span> -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">    sleep 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Cancelled transfer</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    /opt/homebrew/bin/sz <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> -e -b</span><br><span class="line">    sleep 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Received $FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>


<p>注意：文档中else后的路径根据lrzsz地址填写。</p>
<h2 id="给两个sh添加权限"><a href="#给两个sh添加权限" class="headerlink" title="给两个sh添加权限"></a>给两个sh添加权限</h2><p>cd /opt/homebrew/bin</p>
<p>chmod +x iterm2-send-zmodem.sh</p>
<p>chmod +x iterm2-recv-zmodem.sh</p>
<h2 id="设置iterm2的触发器（triggers）"><a href="#设置iterm2的触发器（triggers）" class="headerlink" title="设置iterm2的触发器（triggers）"></a>设置iterm2的触发器（triggers）</h2><p>在iterm2中的“Preferences”面板-&gt;Profiles选项卡-&gt;Advanced-&gt;Triggers（点击Edit便可）</p>
<p>Regular expression: **B0100<br>    Action: Run Silent Coprocess<br>    Parameters: /usr/local/bin/iterm2-send-zmodem.sh<br>Regular expression: **B00000000000000<br>    Action: Run Silent Coprocess<br>    Parameters: /usr/local/bin/iterm2-recv-zmodem.sh<br>添加后如图：<br><img src="/image/16347304425454.jpg"></p>
<p>勾选了 instant 就不须要重启items2了，而后就能够传输文件了。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>sz filename (发送文件到客户端,zmodem接收可以自行启动)<br>rz (从客户端上传文件到linux服务端)</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的数组、切片、结构体与指针</title>
    <url>/2021/10/26/Go%E7%9A%84%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="数组、切片和映射"><a href="#数组、切片和映射" class="headerlink" title="数组、切片和映射"></a>数组、切片和映射</h1><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numsTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cheeses [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">	cheeses[<span class="number">0</span>] = <span class="string">&quot;first&quot;</span></span><br><span class="line">	cheeses[<span class="number">1</span>] = <span class="string">&quot;get two cheeses&quot;</span></span><br><span class="line">	<span class="comment">// first</span></span><br><span class="line">	fmt.Println(cheeses[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">// get two cheeses</span></span><br><span class="line">	fmt.Println(cheeses[<span class="number">1</span>])</span><br><span class="line">	<span class="comment">// [first get two cheeses]</span></span><br><span class="line">	fmt.Println(cheeses)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接fmt打印数组，会将数组中所有值打印出来。<br>已经定义好数组长度的话，就不能再插入超过长度的值。设置<code>cheeses[2]</code>会报错</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="切片新增"><a href="#切片新增" class="headerlink" title="切片新增"></a>切片新增</h3><p>因为数组定义后不能在更改长度的特性，引入切片的概念。<br>切片相当于一个数组的封装、但是添加了增加长度、删除、复制等的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cupTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cheeses = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	cheeses[<span class="number">0</span>] = <span class="string">&quot;AA&quot;</span></span><br><span class="line">	cheeses[<span class="number">1</span>] = <span class="string">&quot;BB&quot;</span></span><br><span class="line">	cheeses = <span class="built_in">append</span>(cheeses, <span class="string">&quot;CC&quot;</span>)</span><br><span class="line">	<span class="comment">// [AA BB CC]</span></span><br><span class="line">	fmt.Println(cheeses)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义时通过内置make函数来定义切片、第一个参数为数据类型、第二个为原始长度。<br>append()方法会将切片的长度增加，并填充参数。该方法是不定参数函数，所以可以通过该函数一次添加多个参数。<br>append()方法会将切片的长度增加，就算没有定义<code>cheeses[1] = &quot;BB&quot;</code>，也会新增长度，不会把参数填充到index=1的位置。</p>
<h3 id="切片删除"><a href="#切片删除" class="headerlink" title="切片删除"></a>切片删除</h3><p>如下是删除切片中index为2的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cheeses = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">	cheeses[<span class="number">0</span>] = <span class="string">&quot;Mariolles&quot;</span></span><br><span class="line">	cheeses[<span class="number">1</span>] = <span class="string">&quot;Époisses de Bourgogne&quot;</span></span><br><span class="line">	cheeses[<span class="number">2</span>] = <span class="string">&quot;Camembert&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(cheeses))</span><br><span class="line">	fmt.Println(cheeses)</span><br><span class="line">	cheeses = <span class="built_in">append</span>(cheeses[:<span class="number">2</span>], cheeses[<span class="number">2</span>+<span class="number">1</span>:]...)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(cheeses))</span><br><span class="line">	fmt.Println(cheeses)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/image/16352318749270.jpg"></p>
<h3 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copeTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cheeses = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	cheeses[<span class="number">0</span>] = <span class="string">&quot;Mariolles&quot;</span></span><br><span class="line">	cheeses[<span class="number">1</span>] = <span class="string">&quot;Époisses de Bourgogne&quot;</span></span><br><span class="line">	<span class="keyword">var</span> smellyCheeses = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="built_in">copy</span>(smellyCheeses, cheeses)</span><br><span class="line">	fmt.Println(smellyCheeses)</span><br><span class="line">	<span class="comment">// [Mariolles Époisses de Bourgogne]</span></span><br><span class="line"></span><br><span class="line">&lt;!--只复制cheese中index1之后的--&gt;</span><br><span class="line">	<span class="keyword">var</span> smellyCheeses2 = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="built_in">copy</span>(smellyCheeses2, cheeses[<span class="number">1</span>:])</span><br><span class="line">	fmt.Println(smellyCheeses2)</span><br><span class="line">	<span class="comment">// [Époisses de Bourgogne ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射相当于go中的Map，是一个k-v格式的数据结构。映射可以不指定长度、随意增加减少长度。<br>初始化与赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> players = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	players[<span class="string">&quot;cook&quot;</span>] = <span class="number">32</span></span><br><span class="line">	players[<span class="string">&quot;key2&quot;</span>] = <span class="number">27</span></span><br><span class="line">	players[<span class="string">&quot;stokes&quot;</span>] = <span class="number">26</span></span><br><span class="line">	fmt.Println(players[<span class="string">&quot;cook&quot;</span>]) <span class="comment">//32</span></span><br><span class="line">	fmt.Println(players[<span class="string">&quot;key2&quot;</span>]) <span class="comment">//27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过make进行初始化，key为string类型、value为int类型。</p>
<p>删除映射中k-v对，通过内置的delete方法进行删除。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> players = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	players[<span class="string">&quot;cook&quot;</span>] = <span class="number">32</span></span><br><span class="line">	players[<span class="string">&quot;bairstow&quot;</span>] = <span class="number">27</span></span><br><span class="line">	players[<span class="string">&quot;stokes&quot;</span>] = <span class="number">26</span></span><br><span class="line">	<span class="built_in">delete</span>(players, <span class="string">&quot;cook&quot;</span>)</span><br><span class="line">	fmt.Println(players)</span><br><span class="line">	<span class="comment">// map[bairstow:27 stokes:26]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>定义结构体并初始化<br>当定义结构后，如果只初始化不赋值，结构体中的值为各类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Rating <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Movie&#123;</span><br><span class="line">		Name:   <span class="string">&quot;Ma&quot;</span>,</span><br><span class="line">		Rating: <span class="number">100</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m.Name, m.Rating)</span><br><span class="line">	<span class="comment">// Ma 100</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// var n Movie</span></span><br><span class="line">	n := <span class="built_in">new</span>(Movie)</span><br><span class="line">	n.Name = <span class="string">&quot;name&quot;</span></span><br><span class="line">	n.Rating = <span class="number">110</span></span><br><span class="line">	fmt.Println(n.Name, n.Rating)</span><br><span class="line">	<span class="comment">// name 110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，使用结构体时可以嵌套。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Superhero <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Age     <span class="keyword">int</span></span><br><span class="line">	Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Number <span class="keyword">int</span></span><br><span class="line">	Street <span class="keyword">string</span></span><br><span class="line">	City   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := Superhero&#123;</span><br><span class="line">		Name: <span class="string">&quot;Batman&quot;</span>,</span><br><span class="line">		Age:  <span class="number">32</span>,</span><br><span class="line">		Address: Address&#123;</span><br><span class="line">			Number: <span class="number">1007</span>,</span><br><span class="line">			Street: <span class="string">&quot;Mountain Drive&quot;</span>,</span><br><span class="line">			City:   <span class="string">&quot;Gotham&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各类型的零值如下：<br><img src="/image/16352495813181.jpg" alt="-w987"></p>
<h2 id="结构体的比较"><a href="#结构体的比较" class="headerlink" title="结构体的比较"></a>结构体的比较</h2><p>如果结果相同的结构体，比值是否相同。可以通过<code>==</code>或者<code>!=</code>来判断<br>如果结果不同的结构体，直接使用==比较会报错。<br>可以使用<code>reflect.TypeOf(m)</code>来判断结构体类型。</p>
<p><strong>如果要导出、使用结构体中的某字段，则需要在定义时该字段必须为大写开头</strong>，上面的结构均为可导出。</p>
<p>结构体的<code>m := n</code>是值引用，修改m不会影响到n。<br>如果想同步，可以使用指针引用的方式<code>m := &amp;n</code>，这样m和n操作的就是同一块内存了。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的方法与接口以及错误处理</title>
    <url>/2021/10/27/go%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法类似于函数，但是有一点不同，严格说 方法是结构体的一种类型。是与结构体绑定的一个概念，将方法绑定到结构体后，在任何用到该结构体的地方都可以使用该方法。该结构体被称为该方法的接收者。</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Rating <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Movie)</span> <span class="title">summary</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	r := strconv.FormatFloat(m.Rating, <span class="string">&#x27;f&#x27;</span>, <span class="number">1</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">return</span> m.Name + <span class="string">&quot;, &quot;</span> + r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Movie&#123;</span><br><span class="line">		Name:   <span class="string">&quot;Spiderman&quot;</span>,</span><br><span class="line">		Rating: <span class="number">3.2</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m.summary())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针引用和值引用"><a href="#指针引用和值引用" class="headerlink" title="指针引用和值引用"></a>指针引用和值引用</h3><p>方法是一个接受 <strong>接收者</strong> 的特殊参数的函数，接收者可以是指针、也可以是值。对应了指针引用和值引用。<br>指针引用：会修改传递的原值<br>值引用：传递的是值副本，对副本操作不会对原始数据有影响</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递示例：</span></span><br><span class="line"><span class="keyword">type</span> Triangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	base   <span class="keyword">float64</span></span><br><span class="line">	height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Triangle)</span> <span class="title">changeBase</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	t.base = f</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := Triangle&#123;base: <span class="number">3</span>, height: <span class="number">1</span>&#125;</span><br><span class="line">	t.changeBase(<span class="number">4</span>)</span><br><span class="line">	fmt.Println(t.base) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Triangle)</span> <span class="title">changeBase</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	t.base = f</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := Triangle&#123;base: <span class="number">3</span>, height: <span class="number">1</span>&#125;</span><br><span class="line">	t.changeBase(<span class="number">4</span>)</span><br><span class="line">	fmt.Println(t.base) <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当需要修改原始结构体，就是用指针；如果需要操作结构体，但是不需要修改原始结构体，就是用值。</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>要满足接口的需求，要实现他指定的方法集，并且函数签名正确无误即可。<br>接口示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Robot <span class="keyword">interface</span> &#123;</span><br><span class="line">	PowerOn() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T850 <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *T850)</span> <span class="title">PowerOn</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> R2D2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	Broken <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *R2D2)</span> <span class="title">PowerOn</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.Broken &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;R2D2 is broken&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Boot</span><span class="params">(r Robot)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.PowerOn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	t := T850&#123;</span><br><span class="line">		Name: <span class="string">&quot;The Terminator&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r := R2D2&#123;</span><br><span class="line">		Broken: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := Boot(&amp;r)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Robot is powered on!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = Boot(&amp;t)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Robot is powered on!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>go语言的错误处理，一般是在函数调用时候返回两个值。一个是正常情况下返回的result，而另一个就是如果发送错误会返回的err值。所以调用函数后会先对err值判断是否为nil，如果不是则说明函数调用发生了异常错误。<br>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> file []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	file, err = ioutil.ReadFile(<span class="string">&quot;foo.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s&quot;</span>, file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>在go中错误其实是一个值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这个我们可以自己创建不同的错误类型。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Half takes an integer and returns half the value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Half</span><span class="params">(numberToHalf <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> numberToHalf%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, fmt.Errorf(<span class="string">&quot;Cannot half %v&quot;</span>, numberToHalf)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> numberToHalf / <span class="number">2</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n, err := Half(<span class="number">19</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>21-11-05关于播客的杂记</title>
    <url>/2021/11/05/21-11-05%E5%85%B3%E4%BA%8E%E6%92%AD%E5%AE%A2%E7%9A%84%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>这里是一些关于录制播客的个人想法记录。包括播客叫什么、第一期包括什么内容，一些个人的头脑风暴。</p>
<span id="more"></span>

<h1 id="播客叫什么"><a href="#播客叫什么" class="headerlink" title="播客叫什么"></a>播客叫什么</h1><p>一个无意义相关的词。<br>虚妄之言</p>
<h1 id="第一期聊什么"><a href="#第一期聊什么" class="headerlink" title="第一期聊什么"></a>第一期聊什么</h1><p>P1自我介绍，mask、少爷、立冬、初雪、吃火锅<br>P2为什么要做音频节目，记录生活、偶尔输出、绝不评判、之前做过的fm<br>P3为什么要叫这个名字，都是随便说说、不一定对<br>P4怎么理解虚无主义，快乐的阈值<br>P5最近推荐一首歌：北京的冬天 老狼</p>
<p>一些其他的想法<br>录制时需要一点环境音，果壳之前的第一期开头开易拉罐的声音就很不错，可以持续形成定式。<br>燃香打火机声音。</p>
<h1 id="一些选题"><a href="#一些选题" class="headerlink" title="一些选题"></a>一些选题</h1><p>【合作】买书如同恋爱，都是主观的选择。<br>【合作】年度flag都还在吗<br>【单人】歌曲、李志<br>【单人】蛤蟆先生去看心理医生<br>【】</p>
]]></content>
      <categories>
        <category>播客</category>
      </categories>
      <tags>
        <tag>播客</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的Goroutine并发以及通道</title>
    <url>/2021/11/01/Go%E7%9A%84Goroutine%E5%B9%B6%E5%8F%91%E4%BB%A5%E5%8F%8A%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<h1 id="Goroutine并发"><a href="#Goroutine并发" class="headerlink" title="Goroutine并发"></a>Goroutine并发</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>上面是并发，下面是并行。<br><img src="/image/16363743893511.jpg"></p>
<span id="more"></span>

<p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的<br><img src="/image/16363742964656.jpg"><br>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<br><img src="/image/16363743310665.jpg"></p>
<h2 id="使用Goroutine处理并发操作"><a href="#使用Goroutine处理并发操作" class="headerlink" title="使用Goroutine处理并发操作"></a>使用Goroutine处理并发操作</h2><p>Goroutine类似与Java的线程，但是在go中不需要对Goroutine进行线程管理，创建Goroutine占用的资源很少，可以创建几千个，而且创建和销毁的效率都很高。<br>实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slowFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;slowFunc() finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> slowFunc()</span><br><span class="line">	fmt.Println(<span class="string">&quot;I am now shown straightaway!&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>通道是Goroutine之间通信的方式。所以Goroutine之间不是通过共享内存来通信，而是通过通信来共享内存。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>通道的基本使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> slowFunc(c)</span><br><span class="line"></span><br><span class="line">	msg := &lt;-c</span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slowFunc</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	c &lt;- <span class="string">&quot;slowFunc() finished&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个存储字符串数据的通道，并将其赋值给变量c</li>
<li>使用一个go来执行slowFunc</li>
<li>函数slowFunc将通道当做参数，slowFunc函数单个参数指定了一个通道和一个字符串的数据类型。</li>
<li>声明变量msg，用于接受通道c的信息。<strong>这里将阻塞进程知道收到消息位置</strong></li>
<li>函数slowFunc执行完毕后向通道c发送一条信息</li>
<li>接受并打印，然后因为没有其他语句 退出。</li>
</ol>
<h2 id="使用缓冲通道"><a href="#使用缓冲通道" class="headerlink" title="使用缓冲通道"></a>使用缓冲通道</h2><p>在使用通道时候，可以没有接收者。这种情况下，可以使用缓冲通道。<br>要创建缓冲通道，使用make带一个表示缓冲区长度的参数。<br><code>message := make(chan string ,2)</code><br>这是可以给通道<code>&lt;-</code>传递两条信息，多了会报错。<br>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiver</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> msg := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	messages &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">	messages &lt;- <span class="string">&quot;world&quot;</span></span><br><span class="line">	<span class="built_in">close</span>(messages)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Pushed two messages onto channel with no receivers&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	receiver(messages)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>close()用来关闭通道，禁止再向通道发送信息</li>
<li>receiver()使用range迭代通道，并将通道中信息打印。</li>
</ol>
<h2 id="阻塞和流程控制"><a href="#阻塞和流程控制" class="headerlink" title="阻塞和流程控制"></a>阻塞和流程控制</h2><p>在使用go时候会立刻返回（非阻塞），所以要让进程处于阻塞状态。<strong>给通道指定消息接收者是一个阻塞操作，他可以阻塞函数返回，直到收到一条消息为止。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pinger</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	t := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		c &lt;- <span class="string">&quot;ping&quot;</span></span><br><span class="line">		&lt;-t.C</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> pinger(messages)</span><br><span class="line">	msg := &lt;-messages</span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--输出： ping--&gt;</span><br></pre></td></tr></table></figure>

<p>因为打印后一次就结束了，所以可以给接受通道部分加for来一直接收消息，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pinger</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	t := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		c &lt;- <span class="string">&quot;ping&quot;</span></span><br><span class="line">		&lt;-t.C</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> pinger(messages)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		msg := &lt;-messages</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出会一直在控制台打印ping、ping、ping</p>
<h2 id="将通道做为函数参数"><a href="#将通道做为函数参数" class="headerlink" title="将通道做为函数参数"></a>将通道做为函数参数</h2><p>通道可以做为函数的参数传递。<br><strong>注意：<br>&lt;-在关键字chan左边时候（message &lt;-chan string），通道在函数内是只读；<br>&lt;-在chan右边时（message chan&lt;- string），通道在函数内是只写的；<br>如果没有指定&lt;-时（message chan string），表示通道在函数内可读写。</strong></p>
<h2 id="使用select语句"><a href="#使用select语句" class="headerlink" title="使用select语句"></a>使用select语句</h2><p>当有多个go，持续要根据最先返回的Goroutine执行相应操作，这时可以使用select语句。这时哪个case先收到通道消息，就执行对应case，然后不再阻塞。<br>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping1</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	c &lt;- <span class="string">&quot;ping on channel1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping2</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	c &lt;- <span class="string">&quot;ping on channel2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	channel1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	channel2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> ping1(channel1)</span><br><span class="line">	<span class="keyword">go</span> ping2(channel2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg1 := &lt;-channel1:</span><br><span class="line">		fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line">	<span class="keyword">case</span> msg2 := &lt;-channel2:</span><br><span class="line">		fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// select语句设置超时时间</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">		fmt.Println(<span class="string">&quot;no messages received. giving up.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--received ping on channel2--&gt;</span><br></pre></td></tr></table></figure>
<p>其中第三个case，是为了给select语句设置超时时间，当在0.5s后没有收到任务通道信息后，就直接打印返回。</p>
<h2 id="退出通道"><a href="#退出通道" class="headerlink" title="退出通道"></a>退出通道</h2><p>除了用上面的定时关闭以外，还可以直接调用关闭通道。<br>例如在循环的阻塞过程中，可以调用手动在stop通道传递消息停止阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stop := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- stop:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> msg := &lt;- message:</span><br><span class="line">            fmt.Println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">responseTime</span><span class="params">(url <span class="keyword">string</span>, c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">	res, err := http.Get(url)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">	elapsed := time.Since(start).Seconds()</span><br><span class="line"></span><br><span class="line">	c &lt;- fmt.Sprintf(<span class="string">&quot;%s took %v seconds \n&quot;</span>, url, elapsed)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	urls := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">	urls[<span class="number">0</span>] = <span class="string">&quot;https://www.usa.gov/&quot;</span></span><br><span class="line">	urls[<span class="number">1</span>] = <span class="string">&quot;https://www.gov.uk/&quot;</span></span><br><span class="line">	urls[<span class="number">2</span>] = <span class="string">&quot;http://www.gouvernement.fr/&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		<span class="keyword">go</span> responseTime(u, c)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timeout := time.After(<span class="number">300</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(urls); i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-c:</span><br><span class="line">			fmt.Println(res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			fmt.Println(<span class="string">&quot;timeout reached&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>通过代理解决Chrome等访问Google问题</title>
    <url>/2021/11/12/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3Chrome%E7%AD%89%E8%AE%BF%E9%97%AEGoogle%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Chrome级别"><a href="#Chrome级别" class="headerlink" title="Chrome级别"></a>Chrome级别</h1><ol>
<li>在<a href="https://github.com/FelisCatus/SwitchyOmega/releases%E4%B8%8B%E8%BD%BDSwitchyOmega">https://github.com/FelisCatus/SwitchyOmega/releases下载SwitchyOmega</a></li>
<li>chrome打开：开启开发者模式，把扩下载的crx拖到页面，安装扩展<span id="more"></span>
<img src="/image/16366997208734.jpg"><br>选择新建情景模式<br><img src="/image/16366997790495.jpg"></li>
</ol>
<p>输入情景模式名称，选择PAC情景模式，点击创建<br><img src="/image/16366997529988.jpg"></p>
<p>输入PAC网址：<code>http://pac.internal.baidu.com/bdnew.pac</code>，然后点击立即更新情景模式<br><img src="/image/16366998137723.jpg"></p>
<h1 id="系统级别（推荐）"><a href="#系统级别（推荐）" class="headerlink" title="系统级别（推荐）"></a>系统级别（推荐）</h1><p>另外如果想同时支持多个浏览器翻墙代理，可以直接把代理配置在系统网络上，进行如下操作即可<br>选择  系统偏好设置 → 网络→ 选择已链接网络→ 高级（如下图）<br><img src="/image/16367000256151.jpg"></p>
<p>选择 代理tab，勾选自动代理设置，右侧url填写 <a href="http://pac.internal.baidu.com/bdnew.pac">http://pac.internal.baidu.com/bdnew.pac</a> 即可 （如下图，注意设置了这种模式不需要再设置chrome翻墙插件，pac代理只对部分url进行代理，所以没有性能影响）<br><img src="/image/16367000144361.jpg"></p>
<h1 id="终端层面"><a href="#终端层面" class="headerlink" title="终端层面"></a>终端层面</h1><p>很遗憾，上述脚本只支持http代理，对于终端上的类似curl和wget等命令是不支持的，怎么办呢？<br>这里找一种git翻墙的方式<br>我们查看<a href="http://pac.internal.baidu.com/bdnew.pac%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8F%91%E7%8E%B0%E7%BF%BB%E5%A2%99%E7%9A%84%E4%BB%A3%E7%90%86%E5%9C%B0%E5%9D%80%E4%B8%BA">http://pac.internal.baidu.com/bdnew.pac文件，发现翻墙的代理地址为</a><br><code>agent.baidu.com:8118</code></p>
<p>所以我们可以给git设置代理的方式实现git翻墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy https://agent.baidu.com:8118</span><br><span class="line">git config --global http.proxy http://agent.baidu.com:8118</span><br></pre></td></tr></table></figure>
<p>是不是很聪明</p>
<p>到出https http代理的方式  curl wget等也可正常运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export https_proxy=https://agent.baidu.com:8118</span><br><span class="line">export http_proxy=http://agent.baidu.com:8118</span><br></pre></td></tr></table></figure>

<h1 id="终极大法"><a href="#终极大法" class="headerlink" title="终极大法"></a>终极大法</h1><p><a href="https://ikuuu.co/auth/register?code=ZRmh">https://ikuuu.co/auth/register?code=ZRmh</a><br>懂得都懂</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令合集</title>
    <url>/2021/11/30/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>对常用的一些linux命令进行分类记录，提高使用效率。</p>
<span id="more"></span>

<h1 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h1><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>.tar.gz文件：<br><code>tar -zxvf xxx.tar.gz</code></p>
<p>.gz文件解压：<br><code>gzip -d xxx.gz</code></p>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><h2 id="cpu利用率查看"><a href="#cpu利用率查看" class="headerlink" title="cpu利用率查看"></a>cpu利用率查看</h2><p>1 定点查询某服务cpu利用率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查询pid （第二列值）</span><br><span class="line">ps aux | grep xxxx </span><br><span class="line">// 查询该pid的cpu利用率等</span><br><span class="line">top -p pid</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Go性能分析pprof</title>
    <url>/2021/11/30/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90pprof/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Go 有非常多好用的工具，pprof 可以用来分析一个程序的性能。pprof 有以下 4 种类型：</p>
<p>CPU profiling（CPU 性能分析）：这是最常使用的一种类型。用于分析函数或方法的执行耗时；<br>Memory profiling：这种类型也常使用。用于分析程序的内存占用情况；<br>Block profiling：这是 Go 独有的，用于记录 goroutine 在等待共享资源花费的时间；<br>Mutex profiling：与 Block profiling 类似，但是只记录因为锁竞争导致的等待或延迟。</p>
<span id="more"></span>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="step1-开启"><a href="#step1-开启" class="headerlink" title="step1:开启"></a>step1:开启</h2><p>在main中添加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// for perf performance evaluation</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := http.ListenAndServe(<span class="string">&quot;:9990&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开放一个9990端口用作监控</p>
<h2 id="step2-触发"><a href="#step2-触发" class="headerlink" title="step2:触发"></a>step2:触发</h2><p>在go程序部署的机器上执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 获取应用当前的内存情况</span><br><span class="line">curl &#x27;127.0.0.1:9990/debug/pprof/heap&#x27;  -o mem.prof</span><br><span class="line"></span><br><span class="line">## 采集应用60s内的cpu使用情况</span><br><span class="line">curl &#x27;127.0.0.1:9990/debug/pprof/profile?seconds=120&#x27;  -o cpu.prof</span><br><span class="line"></span><br><span class="line">## 采集应用10s内的goroutine调度与执行情况</span><br><span class="line">curl &#x27;127.0.0.1:9990/debug/pprof/trace?seconds=10&#x27;  -o r.trace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`curl -sK -v http://localhost:9990/debug/pprof/heap &gt; heap.out`</span><br></pre></td></tr></table></figure>
<p>将heap.out传到本地</p>
<h2 id="step3-分析"><a href="#step3-分析" class="headerlink" title="step3:分析"></a>step3:分析</h2><p>启动 PProf 可视化界面，在本地执行以下命令<br><code>go tool pprof -http=:8080 heap.out</code><br>注意：如果出现 Could not execute dot; may need to install graphviz.，就是提示你要安装 graphviz 了 （<code>brew install graphviz</code>）</p>
<p>有两点需要说一下:<br>直接在web界面选择flame graph可以观察火焰图<br>可以使用-base x.prof来做对比, 通常是看两个时间点的内存(图中会有-符号)<br>针对trace内容可以使用需要使用trace工具:<br><code>go tool trace -http :7777 ./r.trace</code></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>火焰图分析：x轴为占用比例，y轴为调用深度<br>1.表现为该go程序的cpu会偶发的飘升到300%多，所以从cpu的火焰图开始分析<br><img src="/image/16382645672878.jpg"></p>
<ul>
<li><p>confloader（必要）：扫描配置文件，这块cpu重构后优化<br><img src="/image/16382647545706.jpg"></p>
</li>
<li><p>nodata_checker：分析其中占用较大模块，其中<code>glog.Infof</code>日志打印可以优化、json拼装部分也可以优化。</p>
</li>
<li><p>runtime：在程序中协程开启较多，上下文切换有代价。</p>
</li>
<li><p>GC：如图可见cpu消耗较大的部分为gc说明是有频繁的垃圾回收，是否有频繁创建大对象的操作，可以分析内存性能。</p>
</li>
</ul>
<p>2.获取meu的火焰图如下：<br>对象数量占用火焰图：<br><img src="/image/16382649977980.jpg"><br>可以看到主要内存大部分仍然为configureManager。重构后解决。</p>
<p>对象内存大小火焰图：<br><img src="/image/16382650905306.jpg"><br>同上，其次是和namespace调用的占用较大。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go项目的包循环依赖问题以及解决方案</title>
    <url>/2021/12/07/Go%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8C%85%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="什么是包循环依赖问题"><a href="#什么是包循环依赖问题" class="headerlink" title="什么是包循环依赖问题"></a>什么是包循环依赖问题</h1><p>golang为了加速编译，不允许包循环引用。类似Java也会有不允许循环依赖的规定。规范的go包安排应该是单向的调用链，比如控制层-&gt;业务层-&gt;数据层。当有同层级的包需要互相引用的时候，可能会出现包循环依赖问题。</p>
<span id="more"></span>

<h2 id="包循环依赖示例"><a href="#包循环依赖示例" class="headerlink" title="包循环依赖示例"></a>包循环依赖示例</h2><p>例如有两个包（a，b）互相依赖，如下：<br>A包代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> A</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hundred666/GoTest/B&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(a <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> B.Add(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(a <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Trim(a, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B包代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> B</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/hundred666/GoTest/A&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goo</span><span class="params">(a <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A.Minus(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + <span class="string">&quot;----&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主代码如下：go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/hundred666/GoTest/A&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	A.Foo(<span class="string">&quot;good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="新建公共接口包（父包），将需要循环调用的函数或方法抽象为接口"><a href="#新建公共接口包（父包），将需要循环调用的函数或方法抽象为接口" class="headerlink" title="新建公共接口包（父包），将需要循环调用的函数或方法抽象为接口"></a>新建公共接口包（父包），将需要循环调用的函数或方法抽象为接口</h2><p>package_i</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package_i</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PackageAInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	PrintA()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PackageBInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	PrintB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package_a</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package_a</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;cycle/package_i&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PackageA <span class="keyword">struct</span> &#123;</span><br><span class="line">	B package_i.PackageBInterface</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PackageA)</span> <span class="title">PrintA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I&#x27;m a!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PackageA)</span> <span class="title">PrintAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a.PrintA()</span><br><span class="line">	a.B.PrintB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package_b</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package_b</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;cycle/package_i&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PackageB <span class="keyword">struct</span> &#123;</span><br><span class="line">	A package_i.PackageAInterface</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b PackageB)</span> <span class="title">PrintB</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I&#x27;m b!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b PackageB)</span> <span class="title">PrintAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b.PrintB()</span><br><span class="line">	b.A.PrintA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新建公共组合包（子包），在组合包中组合调用"><a href="#新建公共组合包（子包），在组合包中组合调用" class="headerlink" title="新建公共组合包（子包），在组合包中组合调用"></a>新建公共组合包（子包），在组合包中组合调用</h2><p>package_c</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package_c</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;cycle/package_a&quot;</span></span><br><span class="line">	<span class="string">&quot;cycle/package_b&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> CombileAB <span class="keyword">struct</span> &#123;</span><br><span class="line">	A *package_a.PackageA</span><br><span class="line">	B *package_b.PackageB</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CombileAB)</span> <span class="title">PrintAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.A.PrintA()</span><br><span class="line">	c.B.PrintB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;cycle/package_a&quot;</span></span><br><span class="line">	<span class="string">&quot;cycle/package_b&quot;</span></span><br><span class="line">	<span class="string">&quot;cycle/package_c&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">new</span>(package_a.PackageA)</span><br><span class="line">	b := <span class="built_in">new</span>(package_b.PackageB)</span><br><span class="line">	c := <span class="built_in">new</span>(package_c.CombileAB)</span><br><span class="line">	c.A = a</span><br><span class="line">	c.B = b</span><br><span class="line">	c.PrintAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局存储需要相互依赖的函数，通过关键字进行调用"><a href="#全局存储需要相互依赖的函数，通过关键字进行调用" class="headerlink" title="全局存储需要相互依赖的函数，通过关键字进行调用"></a>全局存储需要相互依赖的函数，通过关键字进行调用</h2><p>callback_mgr</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> callback_mgr</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> callBackMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	callBackMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterCallBack</span><span class="params">(key <span class="keyword">string</span>, callBack <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	callBackMap[key] = callBack</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallBackFunc</span><span class="params">(key <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> callBack, ok := callBackMap[key]; ok &#123;</span><br><span class="line">		in := <span class="built_in">make</span>([]reflect.Value, <span class="built_in">len</span>(args))</span><br><span class="line">		<span class="keyword">for</span> i, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">			in[i] = reflect.ValueOf(arg)</span><br><span class="line">		&#125;</span><br><span class="line">		outList := reflect.ValueOf(callBack).Call(in)</span><br><span class="line">		result := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(outList))</span><br><span class="line">		<span class="keyword">for</span> i, out := <span class="keyword">range</span> outList &#123;</span><br><span class="line">			result[i] = out.Interface()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;callBack(%s) not found&quot;</span>, key))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package_a</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package_a</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;cycle/callback_mgr&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	callback_mgr.RegisterCallBack(<span class="string">&quot;getA&quot;</span>, <span class="built_in">new</span>(PackageA).GetA)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PackageA <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PackageA)</span> <span class="title">GetA</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;I&#x27;m a!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PackageA)</span> <span class="title">PrintAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a.GetA())</span><br><span class="line">	fmt.Println(callback_mgr.CallBackFunc(<span class="string">&quot;getB&quot;</span>)[<span class="number">0</span>].(<span class="keyword">string</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package_b</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package_b</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;cycle/callback_mgr&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	callback_mgr.RegisterCallBack(<span class="string">&quot;getB&quot;</span>, <span class="built_in">new</span>(PackageB).GetB)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PackageB <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b PackageB)</span> <span class="title">GetB</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;I&#x27;m b!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b PackageB)</span> <span class="title">PrintAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(b.GetB())</span><br><span class="line">	fmt.Println(callback_mgr.CallBackFunc(<span class="string">&quot;getA&quot;</span>)[<span class="number">0</span>].(<span class="keyword">string</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;cycle/package_a&quot;</span></span><br><span class="line">	<span class="string">&quot;cycle/package_b&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">new</span>(package_a.PackageA)</span><br><span class="line">	b := <span class="built_in">new</span>(package_b.PackageB)</span><br><span class="line">	a.PrintAll()</span><br><span class="line">	b.PrintAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis中scan的使用</title>
    <url>/2021/12/24/Redis%E4%B8%ADscan%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="使用keys查询"><a href="#使用keys查询" class="headerlink" title="使用keys查询"></a>使用keys查询</h1><p>有时候需要从 Redis 实例成千上万的 key 中找出特定前缀的 key 列表来手动处理数据，可能是修改它的值，也可能是删除 key。这里就有一个问题，如何从海量的 key 中找出满足特定前缀的 key 列表来？</p>
<span id="more"></span>
<p>Redis 提供了一个简单暴力的指令 keys 用来列出所有满足特定正则字符串规则的 key。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli keys key67*</span><br><span class="line">  1) &quot;key6764&quot;</span><br><span class="line">  2) &quot;key6738&quot;</span><br><span class="line">  3) &quot;key6774&quot;</span><br><span class="line">  4) &quot;key673&quot;</span><br><span class="line">  5) &quot;key6710&quot;</span><br><span class="line">  6) &quot;key6759&quot;</span><br><span class="line">  7) &quot;key6715&quot;</span><br><span class="line">  8) &quot;key6746&quot;</span><br><span class="line">  9) &quot;key6796&quot;</span><br></pre></td></tr></table></figure>
<p>这个指令使用非常简单，提供一个简单的正则字符串即可，但是有很明显的两个缺点。</p>
<ol>
<li>没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，当你看到满屏的字符串刷的没有尽头时，你就知道难受了。</li>
<li>keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</li>
</ol>
<p><strong>建议生产环境屏蔽keys命令</strong></p>
<h1 id="使用scan查询"><a href="#使用scan查询" class="headerlink" title="使用scan查询"></a>使用scan查询</h1><p>Redis 为了解决这个问题，它在 2.8 版本中加入了指令——scan。</p>
<p>scan 相比 keys 具备有以下特点:</p>
<ul>
<li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;</li>
<li>提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是对增量式迭代命令的一种提示(hint)，返回的结果可多可少;</li>
<li>同 keys 一样，它也提供模式匹配功能;</li>
<li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li>
<li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li>
<li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li>
<li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零</li>
</ul>
<h2 id="scan基础使用"><a href="#scan基础使用" class="headerlink" title="scan基础使用"></a>scan基础使用</h2><p><code>SCAN cursor [MATCH pattern] [COUNT count]</code></p>
<p>初始执行scan命令例如scan 0。SCAN命令是一个基于游标的迭代器。<br>这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。<br>当SCAN命令的游标参数被设置为0时，服务器将开始一次新的迭代，而当redis服务器向用户返回值为0的游标时，表示迭代已结束，这是唯一迭代结束的判定方式，而不能通过返回结果集是否为空判断迭代结束。</p>
<p>scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是遍历的 limit hint。<br>第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。<br>一直遍历到返回的 cursor 值为 0 时结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli scan 0 match key99* count 1000</span><br><span class="line">1) &quot;13912&quot;</span><br><span class="line">2)  1) &quot;key997&quot;</span><br><span class="line">    2) &quot;key9906&quot;</span><br><span class="line">    3) &quot;key9957&quot;</span><br><span class="line">    4) &quot;key9902&quot;</span><br><span class="line">    5) &quot;key9971&quot;</span><br><span class="line">    6) &quot;key9935&quot;</span><br><span class="line">    7) &quot;key9958&quot;</span><br><span class="line">    8) &quot;key9928&quot;</span><br><span class="line">    9) &quot;key9931&quot;</span><br><span class="line">   10) &quot;key9961&quot;</span><br><span class="line">   11) &quot;key9948&quot;</span><br><span class="line">   12) &quot;key9965&quot;</span><br><span class="line">   13) &quot;key9937&quot;</span><br><span class="line">   </span><br><span class="line">redis-cli scan 13912 match key99* count 1000</span><br><span class="line">1) &quot;5292&quot;</span><br><span class="line">2)  1) &quot;key996&quot;</span><br><span class="line">    2) &quot;key9960&quot;</span><br><span class="line">    3) &quot;key9973&quot;</span><br><span class="line">    4) &quot;key9978&quot;</span><br><span class="line">    5) &quot;key9927&quot;</span><br><span class="line">    6) &quot;key995&quot;</span><br><span class="line">    7) &quot;key9992&quot;</span><br><span class="line">    8) &quot;key9993&quot;</span><br><span class="line">    9) &quot;key9964&quot;</span><br><span class="line">   10) &quot;key9934&quot;</span><br></pre></td></tr></table></figure>
<p>返回结果分为两个部分：第一部分即 1) 就是下一次迭代游标，第二部分即 2) 就是本次迭代结果集。</p>
<p>从上面的过程可以看到虽然提供的 limit 是 1000，但是返回的结果只有 10 个左右。<br>因为这个 limit 不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数量(约等于)。<br>如果将 limit 设置为 10，你会发现返回结果是空的，但是游标值不为零，意味着遍历还没结束。</p>
<h2 id="更多的-scan-指令"><a href="#更多的-scan-指令" class="headerlink" title="更多的 scan 指令"></a>更多的 scan 指令</h2><p>scan 指令是一系列指令，除了可以遍历所有的 key 之外，还可以对指定的容器集合进行遍历。</p>
<p>zscan 遍历 zset 集合元素，<br>hscan 遍历 hash 字典的元素、<br>sscan 遍历 set 集合的元素。</p>
<p>注意点：<br>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键。<br>而 SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。</p>
<h2 id="大-key-扫描"><a href="#大-key-扫描" class="headerlink" title="大 key 扫描"></a>大 key 扫描</h2><p>有时候会因为业务人员使用不当，在 Redis 实例中会形成很大的对象，比如一个很大的 hash，一个很大的 zset 这都是经常出现的。</p>
<p>这样的对象对 Redis 的集群数据迁移带来了很大的问题，因为在集群环境下，如果某个 key 太大，会让数据导致迁移卡顿。</p>
<p>另外在内存分配上，如果一个 key 太大，那么当它需要扩容时，会一次性申请更大的一块内存，这也会导致卡顿。</p>
<p>如果这个大 key 被删除，内存会一次性回收，卡顿现象会再一次产生。</p>
<p>在平时的业务开发中，要尽量避免大 key 的产生。</p>
<p>如果你观察到 Redis 的内存大起大落，这极有可能是因为大 key 导致的，这时候你就需要定位出具体是那个 key，</p>
<p>进一步定位出具体的业务来源，然后再改进相关业务代码设计。</p>
<p><strong>那如何定位大 key 呢？</strong></p>
<p>为了避免对线上 Redis 带来卡顿，这就要用到 scan 指令，对于扫描出来的每一个 key，使用 type 指令获得 key 的类型，</p>
<p>然后使用相应数据结构的 size 或者 len 方法来得到它的大小，对于每一种类型，保留大小的前 N 名作为扫描结果展示出来。</p>
<p>上面这样的过程需要编写脚本，比较繁琐，不过 Redis 官方已经在 redis-cli 指令中提供了这样的扫描功能，我们可以直接拿来即用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli  --bigkeys</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> average sizes per key <span class="built_in">type</span>.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far &#x27;key316&#x27; with 3 bytes</span><br><span class="line">[00.00%] Biggest string found so far &#x27;key7806&#x27; with 4 bytes</span><br><span class="line">[12.79%] Biggest zset   found so far &#x27;salary&#x27; with 1 members</span><br><span class="line">[13.19%] Biggest string found so far &#x27;counter:__rand_int__&#x27; with 6 bytes</span><br><span class="line">[13.50%] Biggest hash   found so far &#x27;websit&#x27; with 2 fields</span><br><span class="line">[14.37%] Biggest set    found so far &#x27;bbs&#x27; with 3 members</span><br><span class="line">[14.67%] Biggest hash   found so far &#x27;website&#x27; with 3 fields</span><br><span class="line">[30.41%] Biggest list   found so far &#x27;mylist&#x27; with 100000 items</span><br><span class="line">[95.53%] Biggest zset   found so far &#x27;page_rank&#x27; with 3 members</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 10019 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 68990 (avg len 6.89)</span><br><span class="line"></span><br><span class="line">Biggest string found &#x27;counter:__rand_int__&#x27; has 6 bytes</span><br><span class="line">Biggest   list found &#x27;mylist&#x27; has 100000 items</span><br><span class="line">Biggest    set found &#x27;bbs&#x27; has 3 members</span><br><span class="line">Biggest   hash found &#x27;website&#x27; has 3 fields</span><br><span class="line">Biggest   zset found &#x27;page_rank&#x27; has 3 members</span><br><span class="line"></span><br><span class="line">10011 strings with 38919 bytes (99.92% of keys, avg size 3.89)</span><br><span class="line">3 lists with 100003 items (00.03% of keys, avg size 33334.33)</span><br><span class="line">1 sets with 3 members (00.01% of keys, avg size 3.00)</span><br><span class="line">2 hashs with 5 fields (00.02% of keys, avg size 2.50)</span><br><span class="line">2 zsets with 4 members (00.02% of keys, avg size 2.00)</span><br></pre></td></tr></table></figure>
<p>如果你担心这个指令会大幅抬升 Redis 的 ops 导致线上报警，还可以增加一个休眠参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli  --bigkeys -i 0.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> average sizes per key <span class="built_in">type</span>.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far &#x27;key316&#x27; with 3 bytes</span><br><span class="line">[00.00%] Biggest string found so far &#x27;key7806&#x27; with 4 bytes</span><br><span class="line">[12.79%] Biggest zset   found so far &#x27;salary&#x27; with 1 members</span><br><span class="line">[13.19%] Biggest string found so far &#x27;counter:__rand_int__&#x27; with 6 bytes</span><br><span class="line">[13.50%] Biggest hash   found so far &#x27;websit&#x27; with 2 fields</span><br><span class="line">[14.37%] Biggest set    found so far &#x27;bbs&#x27; with 3 members</span><br><span class="line">[14.67%] Biggest hash   found so far &#x27;website&#x27; with 3 fields</span><br><span class="line">[30.41%] Biggest list   found so far &#x27;mylist&#x27; with 100000 items</span><br><span class="line">[95.53%] Biggest zset   found so far &#x27;page_rank&#x27; with 3 members</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 10019 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 68990 (avg len 6.89)</span><br><span class="line"></span><br><span class="line">Biggest string found &#x27;counter:__rand_int__&#x27; has 6 bytes</span><br><span class="line">Biggest   list found &#x27;mylist&#x27; has 100000 items</span><br><span class="line">Biggest    set found &#x27;bbs&#x27; has 3 members</span><br><span class="line">Biggest   hash found &#x27;website&#x27; has 3 fields</span><br><span class="line">Biggest   zset found &#x27;page_rank&#x27; has 3 members</span><br><span class="line"></span><br><span class="line">10011 strings with 38919 bytes (99.92% of keys, avg size 3.89)</span><br><span class="line">3 lists with 100003 items (00.03% of keys, avg size 33334.33)</span><br><span class="line">1 sets with 3 members (00.01% of keys, avg size 3.00)</span><br><span class="line">2 hashs with 5 fields (00.02% of keys, avg size 2.50)</span><br><span class="line">2 zsets with 4 members (00.02% of keys, avg size 2.00)</span><br></pre></td></tr></table></figure>
<p>上面这个指令每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升，但是扫描的时间会变长。</p>
<p>需要注意的是，这个bigkeys得到的最大，不一定是最大。</p>
<p>说明原因前，首先说明bigkeys的原理，非常简单，通过scan命令遍历，各种不同数据结构的key，分别通过不同的命令得到最大的key：</p>
<ul>
<li>如果是string结构，通过strlen判断；</li>
<li>如果是list结构，通过llen判断；</li>
<li>如果是hash结构，通过hlen判断；</li>
<li>如果是set结构，通过scard判断；</li>
<li>如果是sorted set结构，通过zcard判断。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑记录-go中使用forRange指针取值问题</title>
    <url>/2021/12/27/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-go%E4%B8%AD%E4%BD%BF%E7%94%A8forRange%E6%8C%87%E9%92%88%E5%8F%96%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>for range 遍历是go语言中常用的循环结构之一，但是在使用时要注意range要注意遍历取出的值只初始化一次，地址唯一，在使用指针时候可能会出现预期之外的错误。<br>使用时需要注意这一问题，在最近工程中就踩了这个坑。记录一下爬坑内容。</p>
<span id="more"></span>

<h1 id="Go指针"><a href="#Go指针" class="headerlink" title="Go指针"></a>Go指针</h1><p>Go 语言中有指针类型，没有指针的计算，这在一定程度上削弱了指针的功能，但也减少了指针的复杂度，给使用者带了更好的使用体验。在Go 中，类型 <code>*T</code> 是指向类型T的值的指针，&amp;符号会生成一个指向其作用对象的指针，*符号表示指针指向的底层的值。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span>      <span class="comment">// 定义一个指针p </span></span><br><span class="line">i := <span class="number">42</span>         <span class="comment">// 初始化一个整数类型 i </span></span><br><span class="line">p = &amp;i          <span class="comment">// p指针指向i,或者说将 i 的指针赋值给p  </span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 通过指针 p 读取 i</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针 p 设置 i</span></span><br></pre></td></tr></table></figure>
<p>有时候当变量值很大，在函数中传来传去，就会占用大量的内存空间。指针中存了指向变量值的地址，在一定程度上可以使用指针来代替变量值，这样在函数参数传递、各种逻辑计算中，就可以节省大量空间。</p>
<h1 id="踩坑demo"><a href="#踩坑demo" class="headerlink" title="踩坑demo"></a>踩坑demo</h1><p>如果我们要再range中使用指针的话，如以下Demo；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	input := []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> res []*<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, &amp;v)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;v 指针 %p\n&quot;</span>, &amp;v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历查看结果集</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> res&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;value--&gt;:&quot;</span>, *value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--输出结果如下--&gt;</span><br><span class="line">v 指针 <span class="number">0x14000010240</span></span><br><span class="line">v 指针 <span class="number">0x14000010240</span></span><br><span class="line">v 指针 <span class="number">0x14000010240</span></span><br><span class="line">value--&gt;: c</span><br><span class="line">value--&gt;: c</span><br><span class="line">value--&gt;: c</span><br></pre></td></tr></table></figure>
<p>可以看到，我们期望的结果是输出a,b,c。而输出的结果为c,c,c。<br>为了判断为何出现这种情况，我们可以把地址也打出来，发现v的地址没有发送过变化。<br>问题正是出在这里，在for range语句中，v变量用于保存迭代input数组所得的值，但是v只被声明了一次，此后都是将迭代input出的值赋值给v，v变量的内存地址始终未变。所以在res中添加的三次都是同一个地址，在最后一次遍历时将c值存放在这个地址，所以res中的所有值都是c。</p>
<h1 id="避坑方法"><a href="#避坑方法" class="headerlink" title="避坑方法"></a>避坑方法</h1><h2 id="使用中间变量"><a href="#使用中间变量" class="headerlink" title="使用中间变量"></a>使用中间变量</h2><p>引入一个中间变量，每次迭代都重新声明一个变量temp</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">	temp := v</span><br><span class="line">	res = <span class="built_in">append</span>(res, temp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样会有一定的内存开销。</p>
<h2 id="使用下标，引用数据的内存"><a href="#使用下标，引用数据的内存" class="headerlink" title="使用下标，引用数据的内存"></a>使用下标，引用数据的内存</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> k, _ := <span class="keyword">range</span> input &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, &amp;input[k])</span><br><span class="line">		fmt.Printf(<span class="string">&quot;v 指针 %p\n&quot;</span>, &amp;input[k])</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&lt;!--输出结果--&gt;</span><br><span class="line">v 指针 <span class="number">0x14000060180</span></span><br><span class="line">v 指针 <span class="number">0x14000060190</span></span><br><span class="line">v 指针 <span class="number">0x140000601a0</span></span><br><span class="line">value--&gt;: a</span><br><span class="line">value--&gt;: b</span><br><span class="line">value--&gt;: c</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go 语言中的指针在一定程度上可以节省内存的占用，但在使用时一定要注意前后语言环境中是否有变动，以免造成引用同值的锅。<br>特别注意在range时使用指针。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>爬坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【Git基础 1】开始使用</title>
    <url>/2022/01/17/Git%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>新人刚入职遇到的第一个问题可能就是如何使用Git来和同学们一起协同管理代码。这里将准备从最基础的使用，和一些git的原理来归纳下Git的上手过程，争取让新同学看完就可以不用再困惑git的相关问题。</p>
<span id="more"></span>

<h1 id="下载安装。"><a href="#下载安装。" class="headerlink" title="下载安装。"></a>下载安装。</h1><p>访问这个地址<a href="https://git-scm.com/downloads%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84git%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E3%80%82">https://git-scm.com/downloads，下载对应环境下的git安装包，下载安装。</a></p>
<h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><p>创建git仓库有两种形式，一种是直接在本地初始化一个新的git仓库，另一种是从某个git服务器上把一个git仓库克隆到本地，我们常用到的git服务器包括github（开源的）和gitlab（公司内部的）。</p>
<h2 id="在本地初始化一个git仓库"><a href="#在本地初始化一个git仓库" class="headerlink" title="在本地初始化一个git仓库"></a>在本地初始化一个git仓库</h2><p>如果你使用的是windows，打开一个你准备作为git仓库的文件夹，右键选择菜单“git bash here”。如果你使用的是mac或Linux，打开一个终端并cd到一个准备作为git仓库的文件夹，然后输入命令git init，就会创建一个.git文件夹，这个文件夹所在的根目录，就是我们的git仓库。一个git仓库已经搞定了，非常简单吧。</p>
<h2 id="从git克隆一个git仓库到本地"><a href="#从git克隆一个git仓库到本地" class="headerlink" title="从git克隆一个git仓库到本地"></a>从git克隆一个git仓库到本地</h2><p>如果你是git的初学者，并且也只在本地使用git的话，可以忽略这各部分，因为git init就能满足你了。</p>
<p>我们以一个github上的仓库为例。要想把一个github上的仓库克隆到本地，大概分为这么几步：</p>
<ol>
<li>在本机的用户目录中生成一个ssh key用于和git服务器建立连接</li>
<li>把本地的ssh key添加到github的账户中。至此，本地与github服务器的连接已经建立了</li>
<li>使用git clone [url]命令来克隆一个git仓库。<br>当然，ssh配置的操作只执行一次就好，之后github已经完成了对你身份的认证。</li>
</ol>
<h2 id="配置ssh步骤："><a href="#配置ssh步骤：" class="headerlink" title="配置ssh步骤："></a>配置ssh步骤：</h2><p>在用户目录下执行创建ssh命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir .ssh</span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>首先，通过mkdir .ssh来创建一个文件夹（windows文件管理器不允许创建以.开头的文件夹，所以建议通过此命令来创建）。然后进入.ssh文件夹，并通过ssh-keygen命令来创建了一个ssh key。运行这个命令后，如果提示你输入文件名，你就输入id_rsa，如果提示你输入密码，你就输入密码。不想使用密码的话，直接回车就行。这时会生成两个文件，分别是id_rsa和id_rsa.pub。<br>然后在github的设置页面，从左侧的列表中找到“SSH and GPG keys ”，打开后，在页面的右上角点击“new ssh key”按钮，会出现一个表单，title栏随便填写一个名称，并把id_rsa.pub中的内容复制到key栏，点击“add ssh key”按钮，本地和github服务器的连接就建立好了。</p>
<h1 id="设置名字和邮箱"><a href="#设置名字和邮箱" class="headerlink" title="设置名字和邮箱"></a>设置名字和邮箱</h1><p>在我们提交代码之前，我们需要先让git知道自己是谁，通过git config配置用户和邮箱。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name [your name]</span><br><span class="line">git config --global user.email [your email]</span><br></pre></td></tr></table></figure>

<h1 id="进行一次提交"><a href="#进行一次提交" class="headerlink" title="进行一次提交"></a>进行一次提交</h1><p>接下来我们进行一些git的常用操作。以下的所有操作，都是基于git init命令在本地初始化的一个空仓库。</p>
<h2 id="git-status命令"><a href="#git-status命令" class="headerlink" title="git status命令"></a>git status命令</h2><p>git status命令会显示当前git仓库的状态，包括：你当前位于哪个分支，你的哪些文件有改动，以及接下来建议你做哪些操作。</p>
<p>在git仓库的目录中新建一个文件hello.txt，内容为hello,git。然后在git bash中输入下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">===================</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p>git告诉我们，当前位于master分支，有一个未跟踪的文件hello.txt，并且通过git add命令可以使这个文件被提交。</p>
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>git add命令将文件加入到暂存区。你目前可以先理解为，git add之后，就将该文件加入了提交列表。<br>下面使用git add命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add hello.txt</span><br><span class="line">// git add . 为提交所有文件改动</span><br></pre></td></tr></table></figure>
<p>然后再一次执行<code>git status</code>，会得到以下输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.txt</span><br></pre></td></tr></table></figure>
<p>git又告诉我们，hello.txt将会被提交，但我们可以通过<code>git rm --cached &lt;file&gt;</code>命令来把hello.txt移出提交列表。</p>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>git commit命令用来进行一次提交。下面我们就来进行一次提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;新增了hello.txt文件&#x27;</span><br><span class="line">==================</span><br><span class="line">[master (root-commit) 68116ea] 新增了hello.txt文件</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 hello.txt</span><br></pre></td></tr></table></figure>

<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>git log 命令用于查看提交历史。下面来试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">===================</span><br><span class="line">commit 68116eadebf69f3c7e585ce2d09da8741f8a7812</span><br><span class="line">Author: xxx &lt;xxx@menhoo.com&gt;</span><br><span class="line">Date:   Fri Jun 9 21:23:52 2017 +0800</span><br><span class="line"></span><br><span class="line">    新增了hello.txt文件</span><br></pre></td></tr></table></figure>

<p>关于git的简单操作，今天就介绍到这里。下一篇将会深入介绍git的暂存区，以及相关命令。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>【Git基础 2】暂存区</title>
    <url>/2022/01/19/Git%E6%9A%82%E5%AD%98%E5%8C%BA/</url>
    <content><![CDATA[<p>本篇来讨论git的核心，暂存区。首先上一张图。<br><img src="/image/16425628669947.jpg"></p>
<span id="more"></span>

<p>左侧是工作区，也就是我们本地电脑上的文件，中间的Index就是我们讨论的暂存区，右侧是HEAD。HEAD是一个头指针，我会在下一篇博客中讨论HEAD，此处你先理解为HEAD就是git版本库。</p>
<p><strong>上面的这张图，非常非常地重要，如果我下面讨论的东西你有不明白的，这张图可能都会给你答案。</strong></p>
<p>其实，git的绝大部分的操作都是在将文件在工作区、暂存区和版本库中移来移去，就拿上一篇博客中使用的<code>git add</code>和<code>git commit</code>来说吧，<code>git add</code>是把文件从工作区复制到暂存区，<code>git commit</code>又把文件从暂存区复制到或提交到了版本库。</p>
<p>下面通过一些简单的场景，把上面的命令都串一遍。<br>首先，通过<code>git init</code>命令初始化一个空的版本库，然后添加两个新的文件，分别是a.txt和b.txt。此时，工作区有两个文件，暂存区没有文件，版本库也没有文件。</p>
<h1 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add a.txt b.txt</span><br></pre></td></tr></table></figure>
<p>上面的命令将a.txt和b.txt文件从工作区复制到了暂存区。这时三个区域的目录结构是这样的</p>
<ul>
<li>工作区：a.txt , b.txt</li>
<li>暂存区：a.txt , b.txt</li>
<li>版本库：空</li>
</ul>
<h1 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;新增了a.txt和b.txt文件&#x27;</span><br></pre></td></tr></table></figure>
<p>上面的命令将暂存区的所有文件复制到版本库。这时三个区域的目录结构就一样了，都包含a.txt 和 b.txt。</p>
<h1 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h1><p><code>git checkout --&lt;file&gt;</code>命令是用暂存区的某个文件来覆盖工作区，经常用于撤销一些修改，这个命令比较危险，因为会修改工作区，且无法撤销。假设我们现在需要正在编辑a.txt，并且假设需要写两段话，写完第一段时，我们可以通过<code>git add a.txt</code>将a.txt复制到暂存区，这样的话，如果在写第二段时写错了，我们可以直接通过<code>git checkout --a.txt</code>来回到第一段完成时的样子。<br>也就是说，<code>git checkout --&lt;file&gt;</code>是用来使工作区回到上次操作git add时的样子。</p>
<h1 id="git-checkout-HEAD"><a href="#git-checkout-HEAD" class="headerlink" title="git checkout HEAD"></a>git checkout HEAD</h1><p><code>git checkout HEAD &lt;file&gt;</code>命令是用版本库来同时覆盖暂存区和工作区，用来彻底撤销一个修改，这个命令更加危险，因为它会同时修改工作区和暂存区，且无法撤销。还假设你想在a.txt中写两段话，写完第一段时，使用<code>git add a.txt</code>命令先备份到暂存区，然后接着写第二段，写着写着发现思路全错了，就可以通过<code>git checkout HEAD a.txt</code>将工作区和暂存区中a.txt的修改都撤销掉，回到上次操作完git commit时的样子。这个命令要慎用。</p>
<h1 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD"></a>git reset HEAD</h1><p><code>git reset HEAD &lt;file&gt;</code>命令通常用来撤销首次执行git add的操作。假设你新增了一个c.txt文件，并通过<code>git add c.txt</code>将此文件复制到了暂存区，但你很快就发现其实这个文件没必要提交，你可以使用<code>git reset HEAD c.txt</code>命令，它的本质是使用版本库来覆盖暂存区，由于版本库还没有c.txt，所以，覆盖后，暂存区也就没有了c.txt，从而实现了对git add命令的撤销。</p>
<h1 id="git-rm-–cached"><a href="#git-rm-–cached" class="headerlink" title="git rm –cached"></a>git rm –cached</h1><p><code>git rm --cached &lt;file&gt;</code>命令是将一个文件从暂存区删除。那么这有啥用呢？其实还是挺有用的。假设你有一个已经提交到版本库的文件，你发现这个文件其实不应该提交上去（例如配置文件，每个人的都不一样，经常造成冲突），但又不能直接删掉，假设这个文件的名字叫做user.config，你可以这么操作：</p>
<ol>
<li>通过<code>git rm --cached user.config</code>命令将此文件从暂存区删除</li>
<li>通过修改.gitignore文件，把user.config加到文件中，使git忽略这个文件</li>
<li>通过<code>git commit -m &#39;XXX&#39;</code>命令，用暂存区覆盖版本库。由于暂存区没了这个文件，覆盖后，版本库也就没了这个文件，这个文件就被这么从版本库删掉了，但是它还留在你的工作区。</li>
</ol>
<p>是不是有点绕？没关系，多看看最上面的那张图，答案都在那里。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下后台启动java程序</title>
    <url>/2022/02/08/Linux%E4%B8%8B%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8java%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>在Linux中运行java时，期望是后台执行，并且不随命令窗口的关闭而停止。</p>
<span id="more"></span>

<p>以下列举各类启动的情况：</p>
<h1 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h1><p><code>java -jar XXX.jar</code><br>特点：当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出<br>那如何让窗口不锁定？</p>
<h1 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h1><p><code>java -jar XXX.jar &amp;</code><br>&amp;代表在后台运行。<br>特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。<br>继续改进，如何让窗口关闭时，程序仍然运行？</p>
<h1 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h1><p><code>nohup java -jar XXX.jar &amp;</code><br>nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行<br>当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。<br><img src="/image/16442898551788.jpg"></p>
<h1 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h1><p><code>nohup java -jar XXX.jar &gt;temp.txt &amp;</code></p>
<p>解释下 &gt;temp.txt：<br>command &gt;out.file<br>command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
